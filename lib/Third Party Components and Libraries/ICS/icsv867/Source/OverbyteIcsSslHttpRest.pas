{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Author:       Angus Robertson, Magenta Systems Ltd
Description:  HTTPS REST functions, descends from THttpCli, and publishes all
              it's properties and events with additional methods and properties
              for making REST (REpresentional State Transfer) client requests.
              The TSslHttpRest component is a high level version of THttpCli
              that bundles all the extra components for extra functionality,
              including SSL configuration and certificate validation with a
              root bundle, SSL session caching, content compression, content
              code page decoding, persistent cookies, Json handling, logging,
              client SSL certificate.
              Includes functions for OAuth2 and OAuth1A authentication, and
              components to send SMS messages and Tweets.
Creation:     Apr 2018
Updated:      Sept 2021
Version:      8.67
EMail:        francois.piette@overbyte.be  http://www.overbyte.be
Support:      https://en.delphipraxis.net/forum/37-ics-internet-component-suite/
Legal issues: Copyright (C) 2021 by Angus Robertson, Magenta Systems Ltd,
              Croydon, England. delphi@magsys.co.uk, https://www.magsys.co.uk/delphi/

              This software is provided 'as-is', without any express or
              implied warranty.  In no event will the author be held liable
              for any  damages arising from the use of this software.

              Permission is granted to anyone to use this software for any
              purpose, including commercial applications, and to alter it
              and redistribute it freely, subject to the following
              restrictions:

              1. The origin of this software must not be misrepresented,
                 you must not claim that you wrote the original software.
                 If you use this software in a product, an acknowledgment
                 in the product documentation would be appreciated but is
                 not required.

              2. Altered source versions must be plainly marked as such, and
                 must not be misrepresented as being the original software.

              3. This notice may not be removed or altered from any source
                 distribution.

              4. You must register this software by sending a picture postcard
                 to the author. Use a nice stamp and mention your name, street
                 address, EMail address and any comment you like to say.


Overview
--------

TSslHttpRest
------------
This descends from THttpCli, and publishes all it's properties and events with
additional methods and properties for making REST (REpresentional State Transfer)
client requests.  It bundles many optional HTTP units, including SslContext,
content compression, cookie support, SSL/TLS certificate chain checks, content
code page decoding to widestring, etc, logging, Json or XML parameters and
responses, usually simplifying HTTP support to a few lines and one or two event
handlers.  


TSimpleWebSrv
-------------
This is a simple web server primarily designed for accepting HTTP and HTTPS requests
from REST servers which don't expect real pages to be sent, but also for .well-known
responses generated by applications.  Allows listening on multiple IPs and ports.


TRestOAuth
----------
This for handling 0Auth authorization to web apps, by several means.  Beware
OAuth is really a concept with differing implementations, so that implementation
may not always be straight forward.  OAuth1 and 1A were originally developed for
Twitter and use cryptography, OAuth2 is a simpler and easier to implement version
now widely used by most cloud services without any cryptography (other than SSL).

The conceptual issue about OAuth is that applications should not know any login
details.  The login need to be entered through a browser, which then redirects to
a fixed URL which includes an Authorization Code that is subsequently exchanged
for an Access Token that can used by the REST client.  This is really all designed
for interactive applications, on mobile platforms in particular.

Originally it was considered allowable for native applications to display an
embedded browser window in the application to capture the Authorization Code
during redirect.  But that potentially means the application can also capture the
login as well so is no longer best practice, see RFC8252, and some apps will
block the embedded window.

The preferred authorization method is for the native application to launch the
standard browser and redirect to localhost where a small web server runs to
capture the Authorization Code.  That is how TRestOAuth works, transparently
to the user, capturing the Authorization Code and using it for a token grant to
get an Access Token.  Note that Authorization Codes expire in a few minutes and
immediately they are exchanged for a token.

The Access Token is then sent with all HTTPS REST requests as an 'Authorization:
Bearer' header.

Access Tokens often have a limited life and may expire within one to 24 hours.
To avoid user interaction, the token exchange process usually offers a Refresh
Token which can be used to get another Access Token, and this is automatically
handled by TRestOAuth, by refreshing the Access Token before it expires, allowing
 your application to keep running.  Store the Refresh Token securely, since it's
 a potential security risk.

Sometimes the Refresh Token has the same life as the Access Token, with Google
Accounts the Refresh Token remains valid for a few months until the account is
disabled or changed, avoiding needing to login again or refresh within the expiry
period.  Beware with Google the Refresh Token is only returned once after initial
login, not after each refresh.  Google may also need to approve applications
offering OAuth2, and may show consent warnings during the login process to get
an Authorization Code until this is done.
https://developers.google.com/identity/protocols/OAuth2

Setting up OAuth is complex and requires a lot more information than just a site
user name and password.  You normally need to access the desired site and create
an app or client (terminology varies) but will always involve creating a client
ID and client secret, and a redirect URL which will be the local web server.  The
default redirect used by TRestOAuth is http:/localhost:8080/.  There are also
two API URLs, one for the authorization endpoint (displayed in the browser) and
then the token exchange endpoint for REST requests.  Some sites may provide OAuth2
details with the URL (host)/.well-known/openid-configuration as Json, ie:
https://accounts.google.com/.well-known/openid-configuration .   Finally, OAuth
may require the token Scope to be specified, it's purpose or access rights
depending on the server.

Note that in addition to granting tokens using an Authorization Code from a
browser login, some OAuth implementations may support grants for client
credentials alone (ID and secret, without a login) or directly for login and
password (and client ID and secret) which is by far the easiest to use, but not
often available, both are supported by TRestOAuth.


Google and Microsoft OAuth2 Email Application Accounts
------------------------------------------------------

To access email using REST APIs or OAuth2/SMTP/POP3 an 'application account'
needs to be created though the provider console. This is generally done once
by the developer and the application API ID and secret are then distributed
with the application (usually hidden). These are then used by OAuth2 when
logging in with an end user account.  Note end users don't need to access
the provider console or know it exists.

For Google, the console is https://console.developers.google.com/. Go to
Credentials, Create New Credentials, Create OAuth client ID, Web Application,
name the application something like GMailApp, generate the Client Id and Client
Secret, set the Authorised redirect URI to http://localhost:8080/gmail/  and
enable the Gmail API for your account.  All this information enables the
application using this component to access Gmail, once it has also logged
into a Gmail user account usually different to the application account.  The
user account password is unknown to the application, the login process returns
temporary tokens that are used instead of a password.  During the login process
the end user will be asked to give access to the application, which is why the
name must be recognisable.  Google may also need to test your final application
to avoid warnings.

For Microsoft, termininology is more complicated, the console is Microsoft Azure,
https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade
while email is called Microsoft Outlook or Office 365 with the APIs called Micosoft
Graph. Permissions and scopes are horrible, still not sure I understand them.
In the Azure console, take App Registrations, New Registration, app name something
like OutLookEmail, Support account type probably Personal Microsoft Accounts
Only, redirect URI is http://localhost:8080/microsoft/.  Keep the Application
(Client) ID offered, take Certificate & secrets, create client secret and keep
that as well, expires never.  Other settings are needed to allow Microsoft to
authenticate your final application.

With Google, you can not specify which account the users logs into using the
browser, but after login the component retrieves the email acount name in NewEmail.
With Microsoft, you can provide a user name hint that should cause the browser
to offer that name, but the component can only retrieve the email account
using the claim 'profile' which does not seem to work with SMTP/POP3 claims.

After an OAuth2 browser login, you must save the Refresh Token securely since
it is effectively a password to access the user account from this application
account for months from multiple devices.  For unattended applications or
services, the Refresh Token may be copied from another device, beware the token
may finally expire after several months or be cancelled, and will need a fresh
login for a new Refresh Token.

The Access Token need not be saved, for Google and Microsoft it expires after
one hour and will be automatically updated using the Refresh Token.


TIcsInetAlive
-------------
Component to check for IPv4 and/or IPv6 internet connectivity, using Ping
and/or HTTP.

Updates:
May 21, 2018  - V8.54 - baseline
Jul  2, 2018  - V8.55 - Improved Json error handling
                        Builds with NO_DEBUG_LOG
Oct 2, 2018   - V8.57 - Need OAuth local web server for all auth methods.
                        Builds with FMX
Nov 2, 2018   - V8.58 - Bug fixes, call RequestDone event if it fails
                        Descend components from TIcsWndControl not TComponent
Feb 6, 2019   - V8.60 - Default with SocketFamily Any for both IPv4 and IPv6.
                        SessionConnect logging shows IP address as well as host name.
                        Increased OAuth web server timeout from 2 to 30 mins.
Apr 26, 2019  - V8.61 - Prevent TSslHttpCli events being overwritten by TSslHttpRest events.
                        ResponseXX properties available in OnRequestDone and OnRestRequestDone.
                        Return javascript content as well as XML and Json
                        Posted content-type header now specifies UTF-8.
                        Added new TDnsQueryHttps component to make DNS over HTTPS
                           queries using wire format.
                        Added new TIcsSms component to send SMS text messages via
                           an HTTP bureau, you will need an account. Initially
                           supporting https://www.kapow.co.uk/ from where you set-up
                           an account for £6.50 (about $9) which gives 100 message
                           credits. Other similar bureaus can be added, provided
                           there is an account for testing.
Aug 07, 2019  - V8.62 - Add AsyncReq to TIcsSms methods for flexibility.
                        Supporting The SMS Works at https://thesmsworks.co.uk/ for SMS.
                        Simple web server breaks down full URL for proxy requests.
                        TRestParams can add Json parameters as PContJson which
                          means arrays and nested Json can be added.
                        TSimpleWebSrv now supports SSL, with certificate bunder
                          and host name, supports SSL ALPN extension.
                        Added SslAllowSelfSign property to connect OK to sites
                          with self signed SSL certificates.
                        Builds without USE_SSL
Nov 11, 2019  - V8.63 - The SMS Works sync delivery works OK, try and return
                          similar delivery responses as Kapow.
                        Ensure default CA bundle gets loaded if SslRootFile
                          blank (broken in V8.62).
                        Web server now lonnger adds date/time when logging allowing
                          application to do it instead.
                        OAuth2 don't kill old refresh token if no refresh is available,
                           Google APIs provides a single refresh that remains valid for
                           weeks rather than a new one with each access token. Clarified
                           the OAuth documentation to explain the Google process.
                        OAuth has extra TOAuthOptions OAopAuthPrompt and OAopAuthAccess
                           for Google, OAopAuthPrompt uses property LoginPrompt usually
                           'consent', OAopAuthAccess and RefreshOffline=True requests a
                           Refresh Token.
May 05, 2020  - V8.64 - Added support for International Domain Names for Applications (IDNA),
                         i.e. using accents and unicode characters in domain names.
                        Only  REST change here is to report A-Label domain looked up by DNS.
                        SimpleWebSrv returns host: name in Unicode.
                        Added more parameter content types: PContXML, PContBodyUrlEn,
                          PContBodyJson, PContBodyXML. The existing PContUrlEn and
                          PContJson now specify REST params are sent as URL ? arguments,
                          while the PContBodyxx version send params as content body.
                        This fixes a bug that meant PUT request params were always sent
                          as URL ? arguments.  Note POST is always content body so
                          the wrong PContent is corrected automatically for backward
                          compatibility.
                        XML content type is experimental, not tested.
                        Verifying the SSL certificate chain with the Windows Store
                          works again.
                        TDnsQueryHttps component now uses strings and support IDNs.
                        TSimpleWebSrv no longer processes ALPN, done in SocketServer.
                        Made TSimpleWebSrv.WebServer writable to set properties.
Dec 15, 2020 - V8.65 - Added OAuth1A for Twitter, note uses extra secret tokens that
                          OAuth2 does not need.  Each request made using OAuth1A requires
                          a unique signature sent as an Authorization: OAuth header
                          unlike OAuth2 that uses the same bearer token for all requests.
                        Added new TIcsTwitter component to send and receive tweets,
                          requires a developer account from Twitter.  Includes login
                          to Twitter, send tweet, search tweets and get specific
                          tweets, all responses are Json which the application needs
                          to untangle.
                        Don't skip OAuth2 auto refresh if using old refresh token.
                        Using new Superobject ParseStringEx function that logs parsing
                          errors for ResponseJson if it returns nil.
                        For DebugHeaders, report TCP buffer size.
                        Don't add ? to URL if no parameters.
                        Don't try and use Windows certificate store on Posix, or
                           ShellExecute to run a program, pending replacement.
                         Initial Posox support.
                        Changing IcsSms AccountJson now gets a new JWT. Cleaned
                           up SMS error reporting for bad authentication.
                        Added several TOAuthUri records designed to set-up common OAuth2
                          account settings for providers like Google, Twitter, Microsoft
                          and Sipgate, by using the LoadAuthUri method.  Note avoid
                          dragging all URIs into all applications, they need to be
                          referenced specifically in applications.  The REST sample
                          builds an array to allow them to be selected from a list.
                        TRestOAuth has new AccName and ConsoleUrl properties for display.
                        TSimpleWebSrv has new WebSrvIP2 for a second address, setting
                          WebSrvIP to localhost sets 127.0.0.1 and [::1].
                        Added OAuth2 Console URL and button which simply launches
                          the browser to the account console page where an
                          application is set-up and you get the secrets.
                        Added TOAuthOption OAopAuthGrantedScope which include existing
                          granted scopes when adding new ones.
                        If SSL handshake fails due to bad certificate or chain, remove
                          SSL session from cache so an immediate retry does not succeed by
                          skipping the certificate checks.
                        TRestParams AddItem has new overloaded methods to add Integer,
                          Double and Boolean values, AddItemDT for TDateTime, AddItemSO
                          for ISuperObject and AddItemAR for TStrings as Json array.
                           Numerics and bool are saved as Json without quotes which is
                           required for strict Json parsers. Another AddItem overload
                           has a RParamType parameter as TRParamType allowing a string
                           to be added as RPTypeStr, RPTypeInt, RPTypeDate, RPTypeFloat,
                           RPTypeBool, RPTypeObj or RPTypeArray.
                        TRestParams has new RfcStrict method that forces RFC3986 strict
                          URL percent encoding, four unreserved chars (- . _ -) are
                          not percent encoded.
                        TRestParams has new RemoveItem method to delete a parameter.
                        TRestParams has new PContent type of PContCommaList which saves
                           parameters as a name="value", comma separated list for Twitter.
                        Added new TIcsRestEmail component that provides basic support
                          for Google and Microsoft Outlook email REST APIs including
                          OAuth2 login and refresh to get an access token for SMTP
                          smtpAuthXOAuth2 and smtpAuthOAuthBearer authentication.
                        TIcsRestEmail has methods to send and read email, to list IDs in
                          a mailbox, read headers and message bodies by ID, send emails
                          and delete emails.  The OverbyteIcsHttpRestTst1 sample shows
                          how to read all headers, and how to prepare email using the
                          SMTP component (Google) or Json (Microsoft) to be sent using
                          the REST API.
                        TSimpleWebSrv.StopSrv has new argument that does not close
                          current clients so it can be called from a client event
                          to stop new requests.
                        Don't attempt to send a blank POST body.
                        Renamed Ics.Posix.Messages.pas to Ics.Posix.PXMessages.pas.
Mar 19, 2021 - V8.66 -  TIcsRestEmail has new OAAuthType property and event for OAuth2
                           browser URL perhaps via email for servers.
                        TIcsRestEmail sets OAuth2 errors, and clears old tokens.
                        Increased default timeout for TIcsRestEmail AOuth2 login
                           to 120 seconds since several web page warnings may be seen.
                        Added TIcsInetAlive component to check for IPv4 and/or IPv6
                           internet connectivity, using Ping and/or HTTP, defaulting to
                           www.msftconnecttest.com run by Microsoft for Windows 10 alive
                           checking, online and offline check intervals may be set,
                           event when online changes.
                        Report if OpenSSL statically linked.
                        Ensure SSL initialised for non-REST requests like GET/PUT.
                        Made IcsEscapeJson public.
Sep 07, 2021 - V8.67 -  Moved TRestParams to OverbyteIcsUrl to ease circular referencing
                          and reduce size of this unit.
                        TIcsInetAlive better error for ping hops exceeded, and change
                           default from 16 to 25.
                        Replaced Stream.Seek with Stream.Position.



Pending - more documentation
Pending - better SSL error handling when connections fail, due to too high security in particular.
Pending - OAuth don't spawn browser from Windows service
Pending - REST response for DelphiXE Json Objects Framework
}

{$IFNDEF ICS_INCLUDE_MODE}
unit OverbyteIcsSslHttpRest;
{$ENDIF}

{$I Include\OverbyteIcsDefs.inc}

{$IFDEF COMPILER14_UP}
  {$IFDEF NO_EXTENDED_RTTI}
    {$RTTI EXPLICIT METHODS([]) FIELDS([]) PROPERTIES([])}
  {$ENDIF}
{$ENDIF}
{$B-}             { Enable partial boolean evaluation   }
{$T-}             { Untyped pointers                    }
{$X+}             { Enable extended syntax              }
{$H+}             { Use long strings                    }
{$IFDEF BCB}
    {$ObjExportAll On}
{$ENDIF}

interface

{$IFDEF USE_SSL}

uses
{$IFDEF MSWINDOWS}
    {$IFDEF RTL_NAMESPACES}Winapi.Messages{$ELSE}Messages{$ENDIF},
    {$IFDEF RTL_NAMESPACES}Winapi.Windows{$ELSE}Windows{$ENDIF},
    {$IFDEF RTL_NAMESPACES}Winapi.ShellAPI{$ELSE}ShellAPI{$ENDIF},
{$ENDIF}
{$IFDEF POSIX}
    Posix.Time,
    Ics.Posix.WinTypes,
    Ics.Posix.PXMessages,
{$ENDIF}
    {$IFDEF RTL_NAMESPACES}System.Classes{$ELSE}Classes{$ENDIF},
    {$IFDEF RTL_NAMESPACES}System.Sysutils{$ELSE}Sysutils{$ENDIF},
    {$IFDEF RTL_NAMESPACES}System.TypInfo{$ELSE}TypInfo{$ENDIF},
{$IFDEF DATABASE}
//    {$IFDEF RTL_NAMESPACES}Data.DB{$ELSE}DB{$ENDIF},   { V8.67 }
{$ENDIF}
    OverbyteIcsSsleay, OverbyteIcsLibeay,
    OverbyteIcsWinsock,
    OverbyteIcsTypes,
    OverbyteIcsUtils,
    OverbyteIcsUrl,
{$IFDEF FMX}
    Ics.Fmx.OverbyteIcsWndControl,
    Ics.Fmx.OverbyteIcsWSocket,
    Ics.Fmx.OverbyteIcsWSocketS,
    Ics.Fmx.OverbyteIcsHttpProt,
    Ics.Fmx.OverbyteIcsSslSessionCache,
    Ics.Fmx.OverbyteIcsSslX509Utils,
    Ics.Fmx.OverbyteIcsMsSslUtils,
    Ics.Fmx.OverbyteIcsSslJose,
    Ics.Fmx.OverbyteIcsDnsQuery,
    Ics.Fmx.OverbyteIcsPing,
    Ics.Fmx.OverbyteIcsIcmp,
{$ELSE}
    OverbyteIcsWndControl,
    OverbyteIcsWSocket,
    OverbyteIcsWSocketS,
    OverbyteIcsHttpProt,
    OverbyteIcsSslSessionCache,
    OverbyteIcsSslX509Utils,
    OverbyteIcsMsSslUtils,
    OverbyteIcsSslJose,
    OverbyteIcsDnsQuery,
    OverbyteIcsPing,
    OverbyteIcsIcmp,
{$ENDIF FMX}
{$IFDEF MSWINDOWS}
    OverbyteIcsWinCrypt,
{$ENDIF MSWINDOWS}
    OverbyteIcsHttpCCodZLib,
    OverbyteIcsHttpContCod,
    OverbyteIcsLogger,         { for TLogOption }
    OverbyteIcsCookies,
    OverbyteIcsMimeUtils,
    OverbyteIcsFormDataDecoder,
    OverbyteIcsCharsetUtils,
    OverbyteIcsSuperObject,
    OverbyteIcsTicks64;

{ NOTE - these components only build with SSL, there is no non-SSL option }

const
    THttpRestVersion = 867;
    CopyRight : String = ' TSslHttpRest (c) 2021 F. Piette V8.67 ';
    DefMaxBodySize = 100*IcsMBYTE; { max memory/string size 100Mbyte }  { V8.67 literal safer }
    TestState = 'Testing-Redirect';
    MimeDnsJson = 'application/dns-json';
    MimeDnsMess = 'application/dns-message';

    OAuthErrBase                     = {$IFDEF MSWINDOWS} 1 {$ELSE} 1061 {$ENDIF};
    OAuthErrNoError                  = 0;
    OAuthErrParams                   = OAuthErrBase;
    OAuthErrBadGrant                 = OAuthErrBase+1;
    OAuthErrWebSrv                   = OAuthErrBase+2;
    OAuthErrBrowser                  = OAuthErrBase+3;
    OAuthErrEvent                    = OAuthErrBase+4;     { V8.65 }

type
{ forware declarations }
//  TSimpleWebSrv = class;

{ event handlers }
  THttpRestProgEvent = procedure (Sender: TObject; LogOption: TLogOption; const Msg: string) of object;
  TSimpleWebSrvReqEvent = procedure (Sender: TObject; const Host, Path, Params: string; var RespCode, Body: string) of object;
//  TSimpleWebSrvAlpnEvent = procedure (Sender: TObject; const Host: string; var CertFName: string) of object;   { V8.62 }
  TOAuthAuthUrlEvent = procedure (Sender: TObject; const URL: string) of object;

{ property and state types }
  TOAuthProto = (OAuthv1, OAuthv1A, OAuthv2);
  TOAuthType = (OAuthTypeWeb, OAuthTypeMan, OAuthTypeEmbed);
  TOAuthOption = (OAopAuthNoRedir,    { OAuth Auth Request do not send redirect_url }
                  OAopAuthNoScope,    { OAuth Auth Request do not send scope }
                  OAopAuthNoState,    { OAuth Auth Request do not send state }
                  OAopAuthPrompt,     { OAuth Auth Request send approval prompt V8.63 }
                  OAopAuthAccess,     { OAuth Auth Request send access type V8.63 }
                  OAopAuthGrantedScope, { OAuth Auth include granted scope V8.65 Google }
                  OAopAuthRespMode,   { OAuth Auth Request send resp_mode V8.65  Microsoft }
                  OAopAuthLoginHint); { OAuth Auth Request send resp_mode V8.65 Microsoft }
  TOAuthOptions = set of TOAuthOption;

{ TSslHttpRest descends from THttpCli, and publishes all it's properties
   and events with additional methods and properties for making REST
   (REpresentional State Transfer) client requests. }

type
  TSslHttpRest = class(TSslHttpCli)
  private
    { Private declarations }
    FRestParams: TRestParams;
    FDebugLevel: THttpDebugLevel;
    FPostStream: TMemoryStream;
    FResponseJson: ISuperObject;
    FResponseStream: TMemoryStream;
    FResponseRaw: UnicodeString;
    FResponseSize: Integer;
    FMaxBodySize: Int64;
    FInitSsl: Boolean;
    FRespReq: Boolean;
    FSslSessCache: boolean;
    FExternalSslSessionCache: TSslAvlSessionCache;
    FCertVerMethod: TCertVerMethod;
    FSslRootFile: string;
    FSslRevocation: boolean;
    FSslReportChain: boolean;
    FSslAllowSelfSign: boolean;  { V8.62 }
    FSslCliCert: TX509Base;
    FSslCliSecurity:  TSslCliSecurity;
{$IFDEF MSWINDOWS}
    FMsCertChainEngine: TMsCertChainEngine;
{$ENDIF}
    FOnHttpRestProg: THttpRestProgEvent;
    FOnRestRequestDone: THttpRequestDone;
    FOnRestLocChange: TNotifyEvent;
  protected
    { Protected declarations }

    procedure LogEvent(const Msg : String);
    procedure SetRestParams(Value: TRestParams);
    procedure SetSslCliCert(Value: TX509Base);
    procedure SetSslCliSecurity(Value: TSslCliSecurity);
    function  GetResponseJson: ISuperObject;
    function  GetResponseOctet: AnsiString;
    procedure IcsLogEvent (Sender: TObject; LogOption: TLogOption; const Msg : String);
    procedure onCookiesNewCookie(Sender : TObject; ACookie : TCookie; var Save : Boolean);
    procedure TriggerCommand(var S: String); override;  { V8.61 }
    procedure TriggerHeaderData; override;  { V8.61 }
    procedure TriggerLocationChange; override;  { V8.61 }
    procedure TriggerRequestDone2; override;  { V8.61 }
    procedure TriggerDocBegin; override;  { V8.61 }
    procedure TriggerCookie(const Data : String; var   bAccept : Boolean); override;  { V8.61 }
    procedure TriggerSessionConnected; override;  { V8.61 }
    procedure TriggerSessionClosed; override;  { V8.61 }
    procedure TransferSslVerifyPeer(Sender        : TObject;
                                    var Ok        : Integer;
                                    Cert           : TX509Base); override;  { V8.61 }
    procedure TransferSslCliGetSession(Sender      : TObject;
                                   var SslSession  : Pointer;
                                  var FreeSession  : Boolean); override;  { V8.61 }
    procedure TransferSslCliNewSession(Sender      : TObject;
                                      SslSession   : Pointer;
                                      WasReused    : Boolean;
                                  var IncRefCount  : Boolean); override;  { V8.61 }
    procedure TransferSslCliCertRequest(Sender     : TObject;
                                        var Cert   : TX509Base); override;  { V8.61 }
    procedure TransferSslHandshakeDone(Sender      : TObject;
                                       ErrCode    : Word;
                                       PeerCert   : TX509Base;
                                   var Disconnect : Boolean); override;  { V8.61 }
    procedure DoRequestAsync(Rq : THttpRequest); override;               { V8.66 }
  public
    { Public declarations }
    RestCookies: TIcsCookies;
{$IFNDEF NO_DEBUG_LOG}
    RestLogger:  TIcsLogger;
{$ENDIF}
    RestSslCtx:  TSslContext;
    constructor  Create (Aowner: TComponent); override;
    destructor   Destroy; override;
    procedure    InitSsl;
    procedure    ResetSsl;
    procedure    ClearResp;
    function     GetParams: AnsiString;   { V8.64 lost reqtype }
    function     RestRequest(HttpRequest: THttpRequest; const RestURL: String;
                    AsyncReq: Boolean = False; const RawParams: String = ''): Integer;

  published
    { Published declarations }
    property RestParams: TRestParams                    read  FRestParams
                                                        write SetRestParams;
    property DebugLevel:THttpDebugLevel                 read  FDebugLevel
                                                        write FDebugLevel;
    property ResponseRaw: UnicodeString                 read  FResponseRaw;
    property ResponseJson: ISuperObject                 read  GetResponseJson;
    property ResponseOctet: AnsiString                  read  GetResponseOctet;
    property ResponseStream: TMemoryStream              read  FResponseStream;
    property ResponseSize: Integer                      read  FResponseSize;
    property MaxBodySize: Int64                         read  FMaxBodySize
                                                        write FMaxBodySize;
    property SslCliSecurity: TSslCliSecurity            read  FSslCliSecurity
                                                        write SetSslCliSecurity;
    property SslCliCert: TX509Base                      read  FSslCliCert
                                                        write SetSslCliCert;
    property SslSessCache: boolean                      read  FSslSessCache
                                                        write FSslSessCache;
    property CertVerMethod: TCertVerMethod              read  FCertVerMethod
                                                        write FCertVerMethod;
    property SslRootFile: string                        read  FSslRootFile
                                                        write FSslRootFile;
    property SslRevocation: boolean                     read  FSslRevocation
                                                        write FSslRevocation;
    property SslReportChain: boolean                    read  FSslReportChain
                                                        write FSslReportChain;
    property SslAllowSelfSign: boolean                  read  FSslAllowSelfSign
                                                        write FSslAllowSelfSign; { V8.62 }
    property OnBgException;
    property OnHttpRestProg: THttpRestProgEvent         read  FOnHttpRestProg
                                                        write FOnHttpRestProg;
    property OnRestRequestDone: THttpRequestDone        read  FOnRestRequestDone
                                                        write FOnRestRequestDone;
    property OnRestLocChange: TNotifyEvent              read  FOnRestLocChange
                                                        write FOnRestLocChange;
  end;

{ TSimpleWebSrv is a simple web server primarily designed for accepting
   requests from REST servers which don't expect real pages to be sent }

type
{ forware declarations }
  TSimpleWebSrv = class;

  TSimpleClientSocket = class(TSslWSocketClient)
  private
    { Private declarations }
  public
    { Public declarations }
    WebSrv: TSimpleWebSrv;
    RecvBuffer: TBytes;
    RecvWaitTot: Integer; // current data in RecvBuffer
    RecvBufMax: Integer;  // buffer size
    HttpReqHdr: String;
    OnSimpWebSrvReq: TSimpleWebSrvReqEvent;
{ following are parsed from HTTP request header }
    RequestMethod: THttpRequest;        // HTTP request header field
    RequestContentLength: Int64;        // HTTP request header field
    RequestHost: String;                // HTTP request header field
    RequestHostName: String;            // HTTP request header field
    RequestHostPort: String;            // HTTP request header field
    RequestPath: String;                // HTTP request header field
    RequestParams: String;              // HTTP request header field
    RequestReferer: String;             // HTTP request header field
    RequestUserAgent: String;           // HTTP request header field
    procedure CliSendPage(const Status, ContentType, ExtraHdr, BodyStr: String);
    procedure CliErrorResponse(const RespStatus, Msg: string);
    procedure CliDataAvailable(Sender: TObject; Error: Word);
//    procedure CliAlpnChallg(Sender: TObject; const Host: string; var CertFName: string);
    procedure ParseReqHdr;
  end;

  TSimpleWebSrv = class(TIcsWndControl)
  private
    { Private declarations }
    FDebugLevel: THttpDebugLevel;
    FWebSrvIP: string;
    FWebSrvIP2: string;          { V8.65 might need I{v6 as well }
    FWebSrvPort: string;
    FWebSrvPortSsl: string;
    FWebSrvCertBundle: string;   { following V8.62 for SSL }
    FWebSrvCertPassword: string;
    FWebSrvHostName: string;
    FWebSrvRootFile: string;
    FWebServer: TSslWSocketServer;
    FOnServerProg: THttpRestProgEvent;
    FOnSimpWebSrvReq: TSimpleWebSrvReqEvent;
    FOnSimpWebSrvAlpn: TClientAlpnChallgEvent;
  protected
    { Protected declarations }
    procedure LogEvent(const Msg : String);
    procedure SocketBgException(Sender: TObject;
                          E: Exception; var CanClose: Boolean);
    procedure ServerClientConnect(Sender: TObject; Client: TWSocketClient; Error: Word); virtual;
    procedure ServerClientDisconnect(Sender: TObject;
                                 Client: TWSocketClient; Error: Word);
    procedure IcsLogEvent (Sender: TObject; LogOption: TLogOption; const Msg : String);
  public
    { Public declarations }
{$IFNDEF NO_DEBUG_LOG}
    SrvLogger:  TIcsLogger;
{$ENDIF}
    property WebServer: TSslWSocketServer           read  FWebServer
                                                    write FWebServer;  { V8.64 }
    constructor  Create (Aowner: TComponent); override;
    destructor   Destroy; override;
    function  StartSrv: boolean ;
    function  StopSrv(CloseClients: Boolean = True): boolean ;                  { V8.65 }
    function  IsRunning: Boolean;
    function  ListenStates: String;
  published
    { Published declarations }
    property DebugLevel: THttpDebugLevel            read  FDebugLevel
                                                    write FDebugLevel;
    property WebSrvIP: string                       read  FWebSrvIP
                                                    write FWebSrvIP;
    property WebSrvIP2: string                      read  FWebSrvIP2
                                                    write FWebSrvIP2;          { V8.65 }
    property WebSrvPort: string                     read  FWebSrvPort
                                                    write FWebSrvPort;
    property WebSrvPortSsl: string                  read  FWebSrvPortSsl
                                                    write FWebSrvPortSsl;
    property WebSrvCertBundle: string               read  FWebSrvCertBundle
                                                    write FWebSrvCertBundle;   { V8.62  }
    property WebSrvCertPassword: string             read  FWebSrvCertPassword
                                                    write FWebSrvCertPassword;
    property WebSrvHostName: string                 read  FWebSrvHostName
                                                    write FWebSrvHostName;
    property WebSrvRootFile: string                 read  FWebSrvRootFile
                                                    write FWebSrvRootFile;
    property OnSimpWebSrvReq: TSimpleWebSrvReqEvent read  FOnSimpWebSrvReq
                                                    write FOnSimpWebSrvReq;
    property OnServerProg: THttpRestProgEvent       read  FOnServerProg
                                                    write FOnServerProg;
    property OnSimpWebSrvAlpn: TClientAlpnChallgEvent read  FOnSimpWebSrvAlpn
                                                    write FOnSimpWebSrvAlpn; { V8.62 }

  end;

{ TRestOAuth is for handling 0Auth authorization to web apps. Beware OAuth
  does not normally allow applications to specify the actual login to the
  app, this is done via a browser web page }

 type
  TOAuthUri = record     { V8.65 }
    CAccName: string;
    CConsoleUrl: string;
    CAppUrl: string;
    CRedirectUrl: string;
    CTokenUrl: string;
    CReqTokUrl: string;  // OAuth1 only
    CScope: string;
//    CWebSrvIP: string;
//    CWebSrvPort: string;
  end;
  TOAuthUris = array of TOAuthUri;

{ V8.65 these TOAuthUri records are designed to set-up common OAuth2 account
  settings, by using the LoadAuthUri method.  Note to avoid draggings all
  URIs into all applications, they need to be referenced specifically in
  applications.  The REST sample builds an array to allow them to be selected
  from a list.  Note scope=offline may be needed to get a refresh token  }

const
  OAuthUriNone: TOAuthUri = (
    CAccName: 'None' );

  OAuthUriCertCenter: TOAuthUri = (
    CAccName: 'CertCenter Account';
    CConsoleUrl: 'https://my.certcenter.com/my/dashboard';
    CAppUrl: 'https://www.certcenter.com/oauth2/auth';
    CRedirectUrl: 'http://localhost:8080/certcenter/';
    CTokenUrl: 'https://api.certcenter.com/oauth2/token';
    CScope: 'write' );

  OAuthUriGoogle: TOAuthUri = (
    CAccName: 'Google Account';
    CConsoleUrl: 'https://console.developers.google.com/';
    CAppUrl: 'https://accounts.google.com/o/oauth2/auth';
    CRedirectUrl: 'http://localhost:8080/gmail/';
    CTokenUrl: 'https://accounts.google.com/o/oauth2/token';
    CScope: 'https://mail.google.com/' );

// Microsoft identity platform OAuth2
// common = personal/work/school accounts, consumer = Microsoft Account users, organisation = work/school accounts
  OAuthUriMSRest: TOAuthUri = (
    CAccName: 'Microsoft REST Mail APIs';
    CConsoleUrl: 'https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade';
    CAppUrl: 'https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize';
    CRedirectUrl: 'http://localhost:8080/microsoft/';
    CTokenUrl: 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';
    CScope: 'openid offline_access email profile https://graph.microsoft.com/mail.read https://graph.microsoft.com/mail.send https://graph.microsoft.com/mailboxsettings.read' );

  OAuthUriMSSmtp: TOAuthUri = (
    CAccName: 'Microsoft SMTP/POP3';
    CConsoleUrl: 'https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade';
    CAppUrl: 'https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize';
    CRedirectUrl: 'http://localhost:8080/microsoft/';
    CTokenUrl: 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';
    CScope: 'offline_access https://outlook.office.com/SMTP.Send https://outlook.office.com/POP.AccessAsUser.All' );
 // beware, attempting to add profile to scope makes it fail so we can not get email account

  OAuthUriTwitterOA2: TOAuthUri = (
    CAccName: 'Twitter OAuth2 Account';
    CConsoleUrl: 'https://developer.twitter.com/en/account/';
    CAppUrl: 'https://api.twitter.com/oauth/authenticate';
    CRedirectUrl: 'http://localhost:8080/twitter/';
    CTokenUrl: 'https://api.twitter.com/oauth2/token';
    CScope: 'write' );

  OAuthUriTwitterOA1: TOAuthUri = (
    CAccName: 'Twitter OAuth1 Account';
    CConsoleUrl: 'https://developer.twitter.com/en/account/';
    CAppUrl: '';
    CRedirectUrl: 'http://localhost:8080/twitter/';
    CTokenUrl: 'https://api.twitter.com/oauth/access_token';
    CReqTokUrl: 'https://api.twitter.com/oauth/request_token';
    CScope: 'write' );

  OAuthUriSipgate: TOAuthUri = (
    CAccName: 'Sipgate Account';
    CConsoleUrl: 'https://app.sipgate.com/';
    CAppUrl: 'https://login.sipgate.com/auth/realms/third-party/protocol/openid-connect/auth';
    CRedirectUrl: 'http://localhost:8080/sipgate/';
    CTokenUrl: 'https://login.sipgate.com/auth/realms/third-party/protocol/openid-connect/token';
    CScope: 'sessions:sms:write:account:balance' );

{ OAuthUriTwilio: TOAuthUri = (
    CAccName: 'Twilio Account';
    CConsoleUrl: 'https://www.twilio.com/console';
    CAppUrl: '';
    CRedirectUrl: 'http://localhost:8080/twilio/';
    CTokenUrl: '';
    CScope: '' );   }


type
  TRestOAuth = class(TIcsWndControl)
  private
    { Private declarations }
    FDebugLevel: THttpDebugLevel;
    FAccToken: string;
    FAppUrl: string;
    FAuthCode: string;
    FAuthType: TOAuthType;
    FClientId: string;
    FClientSecret: string;
    FScope: string;
    FExpireDT: TDateTime;
    FLastErrCode: Integer;
    FLastError: String;
    FLastWebTick: Longword;
    FOAOptions: TOAuthOptions;
    FProtoType: TOAuthProto;
    FRedirectMsg: string;
    FRedirectUrl: string;
    FRefreshAuto: Boolean;
    FRefreshTimer: TIcsTimer;
    FRefrMinsPrior: Integer;
    FRefreshDT: TDateTime;
    FRefreshToken: string;
    FTokenUrl: string;
    FWebSrvIP: string;
    FWebSrvPort: string;
    FWebServer: TSimpleWebSrv;
    FRedirState: string;
    FRefreshOffline: Boolean;  { V8.63 }
    FLoginPrompt: string;      { V8.63 }
    FAccTokSecret: string;     { V8.65 for OAuth1 }
    FReqTokUrl: string;        { V8.65 for OAuth1 }
    FReqToken: string;         { V8.65 for OAuth1 }
    FReqTokSecret: string;     { V8.65 for OAuth1 }
    FAccName: string;          { V8.65 display only }
    FConsoleUrl: string;       { V8.65 display only }
    FResponseMode: string;     { V8.65 OAuth2 redirect }
    FLoginHint: string;        { V8.65 OAuth2 prefill username/email }
    FOnOAuthProg: THttpRestProgEvent;
    FOnOAuthAuthUrl: TOAuthAuthUrlEvent;
    FOnOAuthNewCode: TNotifyEvent;
    FOnOAuthNewToken: TNotifyEvent;
  protected
    { Protected declarations }
    procedure RestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
    procedure LogEvent(const Msg: String);
    procedure SetError(ErrCode: Integer; const Msg: String);
    procedure SetRefreshDT;
    procedure SetRefreshAuto(Value: Boolean);
    procedure SetRefreshToken(Value: String);
    procedure SetExpireDT(Value: TDateTime);
    procedure WebSrvReq(Sender: TObject; const Host, Path, Params: string; var RespCode, Body: string);
    function  GetToken: boolean;
    procedure RefreshOnTimer(Sender: TObject);
    procedure WebSrvProg(Sender: TObject; LogOption: TLogOption; const Msg: string);  { V8.63 }
    function  GetNonce: String;                                                       { V8.65 }

  public
    { Public declarations }
    HttpRest:    TSslHttpRest;
    OAuthParams: TRestParams;                                                   { V8.65 }
    constructor  Create (Aowner: TComponent); override;
    destructor   Destroy; override;
    function     StartSrv: boolean ;
    function     StopSrv(CloseClients: Boolean = True): boolean ;               { V8.65 }
    function     SrvIsRunning: Boolean;
    function     StartAuthorization: boolean;
    function     GrantAuthToken(const Code: String = ''): boolean;
    function     GrantRefresh: boolean;
    function     GrantPasswordToken(const User, Pass: String): boolean;
    function     GrantAppToken: boolean;
    function     TestRedirect: boolean;
    function     GetOAuthSignature(const Req, Url: string; ReqTok: Boolean = False): String;   { V8.65 }
    procedure    LoadAuthUri(AuthUri: TOAuthUri);                                              { V8.65 }
    function     LaunchConsole: boolean;                                                       { V8.65 }
    procedure    Close;                                                                        { V8.65 }
    property     LastErrCode: Integer               read  FLastErrCode;
    property     LastError: String                  read  FLastError;
    property     RefreshDT: TDateTime               read  FRefreshDT;
  published
    { Published declarations }
    property DebugLevel: THttpDebugLevel            read  FDebugLevel
                                                    write FDebugLevel;
    property AppUrl: string                         read  FAppUrl
                                                    write FAppUrl;
    property AuthCode: string                       read  FAuthCode
                                                    write FAuthCode;
    property AuthType: TOAuthType                   read  FAuthType
                                                    write FAuthType;
    property ClientId: string                       read  FClientId
                                                    write FClientId;
    property ClientSecret: string                   read  FClientSecret
                                                    write FClientSecret;
    property ExpireDT: TDateTime                    read  FExpireDT
                                                    write SetExpireDT;
    property OAOptions: TOAuthOptions               read  FOAOptions
                                                    write FOAOptions;
    property ProtoType: TOAuthProto                 read  FProtoType
                                                    write FProtoType;
    property RedirectMsg: string                    read  FRedirectMsg
                                                    write FRedirectMsg;
    property RedirectUrl: string                    read  FRedirectUrl
                                                    write FRedirectUrl;
    property RefreshAuto: Boolean                   read  FRefreshAuto
                                                    write SetRefreshAuto;
    property RefrMinsPrior: Integer                 read  FRefrMinsPrior
                                                    write FRefrMinsPrior;
    property RefreshToken: string                   read  FRefreshToken
                                                    write SetRefreshToken;
    property Scope: string                          read  FScope
                                                    write FScope;
    property TokenUrl: string                       read  FTokenUrl
                                                    write FTokenUrl;
    property WebSrvIP: string                       read  FWebSrvIP
                                                    write FWebSrvIP;
    property WebSrvPort: string                     read  FWebSrvPort
                                                    write FWebSrvPort;
    property RefreshOffline: Boolean                read  FRefreshOffline
                                                    write FRefreshOffline;  { V8.63 }
    property LoginPrompt: string                    read  FLoginPrompt
                                                    write FLoginPrompt;     { V8.63 }
    property ReqTokUrl: string                      read  FReqTokUrl
                                                    write FReqTokUrl;       { V8.65 for OAuth1 }
    property AccToken: string                       read  FAccToken
                                                    write FAccToken;        { V8.65 for OAuth1 }
    property AccTokSecret: string                   read  FAccTokSecret
                                                    write FAccTokSecret;    { V8.65 for OAuth1 }
    property AccName: string                        read  FAccName
                                                    write FAccName;         { V8.65 display only }
    property ConsoleUrl: string                     read  FConsoleUrl
                                                    write FConsoleUrl;      { V8.65 display only }
    property ResponseMode: string                   read  FResponseMode
                                                    write FResponseMode;    { V8.65 OAuth2 query }
    property LoginHint: string                      read  FLoginHint
                                                    write FLoginHint;       { V8.65 OAuth2 prefill username/email }
    property OnOAuthAuthUrl: TOAuthAuthUrlEvent     read  FOnOAuthAuthUrl
                                                    write FOnOAuthAuthUrl;
    property OnOAuthProg: THttpRestProgEvent        read  FOnOAuthProg
                                                    write FOnOAuthProg;
    property OnOAuthNewCode: TNotifyEvent           read  FOnOAuthNewCode
                                                    write FOnOAuthNewCode;
    property OnOAuthNewToken: TNotifyEvent          read  FOnOAuthNewToken
                                                    write FOnOAuthNewToken;
  end;

  { V8.61 TDnsQueryHttps supports DOH - DNS over HTTPS }
  TDnsQueryHttps = Class(TDnsQuery)
  private
    { Private declarations }
    FDebugLevel: THttpDebugLevel;
    FDnsSrvUrl: string;
    FOnDnsProg: THttpRestProgEvent;
  protected
    { Protected declarations }
    procedure DnsRestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
    procedure DnsRestRequestDone(Sender: TObject; RqType: THttpRequest; ErrCode: Word);
  public
    { Public declarations }
    HttpRest:  TSslHttpRest;
    constructor  Create (Aowner: TComponent); override;
    destructor   Destroy; override;
    function     DOHQueryAll(Host: String): Boolean;          { V8.64 }
    function     DOHQueryAny(Host: String; QNumber: Integer;  { V8.64 }
                                    MultiRequests: Boolean = False) : Boolean;
  published
    { Published declarations }
    property DnsSrvUrl: string                      read  FDnsSrvUrl
                                                    write FDnsSrvUrl;
    property DebugLevel: THttpDebugLevel            read  FDebugLevel
                                                    write FDebugLevel;
    property OnDnsProg: THttpRestProgEvent          read  FOnDnsProg
                                                    write FOnDnsProg;
  end;

  { V8.61 Send SMS using bureau, you will need an account.
    Initially supporting https://www.kapow.co.uk/ from where you set-up an
    account for £6.50 (about $9) which gives 100 message credits.
    Other similar SMS can be added, provided there is an account for testing. }

  { V8.62 Added The SMS Works at https://thesmsworks.co.uk/  where you set-up an
    account with a few free SMS messages, then spend a mininum of £10 which
    buys 350 message credits.  }


  TSmsProvider = (SmsProvKapow, SmsProvSmsWorks); // more providers awaited
  TSmsOperation = (SmsOpSend, SmsOpCheck, SmsOpCredit);

  TIcsSMS = class(TIcsWndControl)
  private
    { Private declarations }
    FDebugLevel: THttpDebugLevel;
    FSmsProvider: TSmsProvider;
    FSmsOperation: TSmsOperation;
    FAccountName: string;
    FAccountPW: string;
    FAccountJson: string;
    FAccountJwt: string;
    FMsgSender: string;
    FSendDT: TDateTime;
    FSentID: string;
    FCredits: string;
    FLastResp: string;
    FLastError: string;
    FDelivery: String;
    FOnSmsProg: THttpRestProgEvent;
    FOnSmsDone: TNotifyEvent;
  protected
    { Protected declarations }
    procedure SmsRestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
    procedure SmsRestRequestDone(Sender: TObject; RqType: THttpRequest; ErrCode: Word);
    function  MakeRequest(HttpRequest: THttpRequest; const RestURL: String;
                      AsyncReq: Boolean = False; const RawParams: String = ''): Boolean;
    procedure SetAccountJson(Value: String);   { V8.65 }
  public
    { Public declarations }
    HttpRest:  TSslHttpRest;
    constructor  Create (Aowner: TComponent); override;
    destructor   Destroy; override;
    function     SendSMS(const MobileNums, SmsMsg: String; AsyncReq: Boolean = True): Boolean;
    function     CheckSMS(ID: String; AsyncReq: Boolean = True; Batch: Boolean = False): Boolean;
    function     CheckCredit(AsyncReq: Boolean = True): Boolean;
    property     SentID: string                     read  FSentID;
    property     Credits: string                    read  FCredits;
    property     LastResp: string                   read  FLastResp;
    property     LastError: string                  read  FLastError;
    property     Delivery: string                    read  FDelivery;
  published
    { Published declarations }
    property SmsProvider: TSmsProvider              read  FSmsProvider
                                                    write FSmsProvider;
    property AccountName: string                    read  FAccountName
                                                    write FAccountName;
    property AccountPW: string                      read  FAccountPW
                                                    write FAccountPW;
    property AccountJson: string                    read  FAccountJson
                                                    write SetAccountJson;
    property MsgSender: string                      read  FMsgSender
                                                    write FMsgSender;
    property SendDT: TDateTime                      read  FSendDT
                                                    write FSendDT;
    property DebugLevel: THttpDebugLevel            read  FDebugLevel
                                                    write FDebugLevel;
    property OnSmsProg: THttpRestProgEvent          read  FOnSmsProg
                                                    write FOnSmsProg;
    property OnSmsDone: TNotifyEvent                read  FOnSmsDone
                                                    write FOnSmsDone;
  end;

{ V8.65 TIcsTwitter to send and receive tweets }
  TIcsTwitter = class(TIcsWndControl)
  private
    { Private declarations }
    FRestOAuth: TRestOAuth;
    FDebugLevel: THttpDebugLevel;
    FLastErrCode: Integer;
    FLastError: String;
    FResponseJson: ISuperObject;
    FResponseRaw: UnicodeString;
    FConApiKey: string;
    FConApiSecret: string;
    FAccToken: string;
    FAccTokSecret: string;
    FRedirectUrl: string;
    FForceLogin: Boolean;
    FAccUserId: string;
    FAccScreenName: string;
    FLastTweetId: string;
    FBaseURL: String;
    FOnTwitProg: THttpRestProgEvent;
    FOnTwitNewToken: TNotifyEvent;
  protected
    { Protected declarations }
    procedure TwitRestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
//    procedure TwitRestRequestDone(Sender: TObject; RqType: THttpRequest; ErrCode: Word);
    procedure TwitNewToken(Sender: TObject);
  public
    { Public declarations }
    HttpRest:  TSslHttpRest;
    constructor  Create (Aowner: TComponent); override;
    destructor   Destroy; override;
    function     StartAuthorization: boolean;
    function     CommonSettings: boolean;
    function     SendTweet(const Msg: String): boolean;
    function     GetAccSett: boolean;
    function     SearchTweets(const Query: String): boolean;
    function     ListTweets(const IdList: String): boolean;
    property     AccUserId: string                  read  FAccUserId;
    property     AccScreenName: string              read  FAccScreenName;
    property     LastTweetId: string                read  FLastTweetId;
    property     LastErrCode: Integer               read  FLastErrCode;
    property     LastError: String                  read  FLastError;
  published
    { Published declarations }
    property ResponseRaw: UnicodeString             read  FResponseRaw;
    property ResponseJson: ISuperObject             read  FResponseJson;
    property ConApiKey: string                      read  FConApiKey
                                                    write FConApiKey;
    property ConApiSecret: string                   read  FConApiSecret
                                                    write FConApiSecret;
    property RedirectUrl: string                    read  FRedirectUrl
                                                    write FRedirectUrl;
    property AccToken: string                       read  FAccToken
                                                    write FAccToken;
    property AccTokSecret: string                   read  FAccTokSecret
                                                    write FAccTokSecret;
    property ForceLogin: Boolean                    read  FForceLogin
                                                    write FForceLogin;
    property DebugLevel: THttpDebugLevel            read  FDebugLevel
                                                    write FDebugLevel;
    property OnTwitProg: THttpRestProgEvent         read  FOnTwitProg
                                                    write FOnTwitProg;
    property OnTwitNewToken: TNotifyEvent           read  FOnTwitNewToken
                                                    write FOnTwitNewToken;
  end;


{ V8.65 TIcsRestEmail to send and receive email with Google and Microsoft REST APIs }

  TRestEmailType = (RestEmailGoogle, RestEmailMSRest, RestEmailMSSmtp);
  TRestEmailFmt = (EmailFmtHdr, EmailFmtRaw, EmailFmtFull);

  TIcsRestEmail = class(TIcsWndControl)
  private
    { Private declarations }
    FRestOAuth: TRestOAuth;
    FDebugLevel: THttpDebugLevel;
    FLastErrCode: Integer;
    FLastError: String;
    FResponseJson: ISuperObject;
    FResponseRaw: UnicodeString;
    FRestEmailType: TRestEmailType;
    FCliID: string;
    FCliSecret: string;
    FAccToken: string;
    FRefrToken: string;
    FAccExpireDT: TDateTime;
    FForceLogin: Boolean;
    FAccountHint: string;
    FLoginTimeout: Integer;
    FNewAccEmail: string;
    FNewAccName: string;
    FNewAccScope: string;
    FTokenType: string;
    FCancelFlag: Boolean;
    FHdrFieldList: String;
    FWaitSecs: Integer;
    FLastEmailId: string;
    FBaseURL: String;
    FOnEmailProg: THttpRestProgEvent;
    FOnEmailNewToken: TNotifyEvent;
    FOAAuthType: TOAuthType;              { V8.66 }
    FOnOAAuthUrl: TOAuthAuthUrlEvent;     { V8.66 }
  protected
    { Protected declarations }
    procedure EmailRestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
    procedure EmailNewToken(Sender: TObject);
    procedure SetRestError;
    procedure SetOAuthErrs;              { V8.66 }
    function  CommonSettings: boolean;
  public
    { Public declarations }
    HttpRest:  TSslHttpRest;
    constructor  Create (Aowner: TComponent); override;
    destructor   Destroy; override;
    procedure    Clear;
    function     TestRedirect: boolean;
    function     StartAuthorization: boolean;
    function     UpdateToken: Boolean;
    function     GetNewToken(Interactive: Boolean = False): Boolean;
    procedure    CancelWait;
    function     LaunchConsole: boolean;
    function     GetProfile: boolean;
    function     ListEmails(const Query: String = '';
                     const MBLabels: String = 'INBOX'; MaxNr: Integer = 100): boolean;
    function     GetEmail(const Id: String; EmailFmt: TRestEmailFmt = EmailFmtHdr): boolean;
    function     SendEmail(const Content: String): boolean;
    function     DeleteEmail(const Id: String): boolean;
    property     NewAccEmail: string                read  FNewAccEmail;
    property     NewAccName: string                 read  FNewAccName;
    property     NewAccScope: string                read  FNewAccScope;
    property     TokenType: string                  read  FTokenType;
    property     LastEmailId: string                read  FLastEmailId;
    property     LastErrCode: Integer               read  FLastErrCode;
    property     LastError: String                  read  FLastError;
    property     WaitSecs: Integer                  read  FWaitSecs;
  published
    { Published declarations }
    property ResponseRaw: UnicodeString             read  FResponseRaw;
    property ResponseJson: ISuperObject             read  FResponseJson;
    property RestEmailType: TRestEmailType          read  FRestEmailType
                                                    write FRestEmailType;
    property ClientId: string                       read  FCliId
                                                    write FCliId;
    property ClientSecret: string                   read  FCliSecret
                                                    write FCliSecret;
    property AccToken: string                       read  FAccToken
                                                    write FAccToken;
    property AccExpireDT: TDateTime                 read  FAccExpireDT
                                                    write FAccExpireDT;
    property RefrToken: string                      read  FRefrToken
                                                    write FRefrToken;
    property ForceLogin: Boolean                    read  FForceLogin
                                                    write FForceLogin;
    property AccountHint: string                    read  FAccountHint
                                                    write FAccountHint;
    property LoginTimeout: Integer                  read  FLoginTimeout
                                                    write FLoginTimeout;
//    property MaxHdrs: Integer                       read  FMaxHdrs
//                                                    write FMaxHdrs;
    property HdrFieldList: String                   read  FHdrFieldList
                                                    write FHdrFieldList;
    property DebugLevel: THttpDebugLevel            read  FDebugLevel
                                                    write FDebugLevel;
    property OAAuthType: TOAuthType                 read  FOAAuthType
                                                    write FOAAuthType;     { V8.66 }
    property OnEmailProg: THttpRestProgEvent        read  FOnEmailProg
                                                    write FOnEmailProg;
    property OnEmailNewToken: TNotifyEvent          read  FOnEmailNewToken
                                                    write FOnEmailNewToken;
    property OnOAAuthUrl: TOAuthAuthUrlEvent        read  FOnOAAuthUrl
                                                    write FOnOAAuthUrl;    { V8.66 }
  end;

{ V8.66 TIcsInetAlive tests for an internet connection in various ways }  
  TAliveMethod = (AliveMethPing, AliveMethHttp, AliveMethBoth);
  TAliveNetwork = (AliveNetv4, AliveNetv6, AliveNetBoth);
  TAliveStatus = (AliveStatNone, AliveStatOffline, AliveStatOnline);                
const
  AliveStatusLits: array[TAliveStatus] of string = ('Not Tested','Offline','Online');
type
  TIcsInetAlive = class(TIcsWndControl)
  private
    { Private declarations }
    FTaskTimer: TIcsTimer;
    FDebugLevel: THttpDebugLevel;
    FAliveMethod: TAliveMethod;
    FAliveNets: TAliveNetwork;
    FHostIPv4: String;
    FHostIPv6: String;
    FLocalIPv4: String;
    FLocalIPv6: String;
    FHttpPage: String;
    FHttpText: String;
    FHttpProxy: String;
    FRunning: Boolean;
    FAliveIPv4: TAliveStatus;
    FAliveIPv6: TAliveStatus;
    FAutoStart: Boolean;
    FOnlineSecs: Integer;
    FOfflineSecs: Integer;
    FPingHops: Integer;
    FPingMaxSecs: Integer;
    FPingCheckAddr: Boolean;
    FFailedWaitSecs: Integer;
    FTrgIPv4: Int64;
    FTrgIPv6: Int64;
    FLastTickIPv4: Int64;
    FLastTickIPv6: Int64;
    FLastDTIPv4: TDateTime;
    FLastDTIPv6: TDateTime;
    FHttpBusy: Boolean;
    FStartTick: Int64;
    FHttpRTT: Integer;
    FPingBusy: Boolean;
    FOnAliveChange: TNotifyEvent;
    FOnAliveProg: THttpRestProgEvent;
  protected
    { Protected declarations }
    procedure AliveRestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
    procedure AliveRestRequestDone(Sender: TObject; RqType: THttpRequest; ErrCode: Word);
    procedure TaskOnTimer(Sender: TObject);
    procedure PingTerminated(Sender: TObject);
    procedure SetOnline(Online: Boolean; IpType: Integer);
    procedure StartHttp(IpType: Integer);
    procedure StartCheck(IpType: Integer);
  public
    { Public declarations }
    HttpRest:  TSslHttpRest;
    constructor  Create (Aowner: TComponent); override;
    destructor   Destroy; override;
    procedure    Start;
    procedure    Stop;
    procedure    CheckNow;
    function     TestBothOnline: TAliveStatus;
    property     Running: Boolean                   read  FRunning;
    property     AliveIPv4: TAliveStatus            read  FAliveIPv4;
    property     AliveIPv6: TAliveStatus            read  FAliveIPv6;
    property     LastTickIPv4: Int64                read  FLastTickIPv4;
    property     LastTickIPv6: Int64                read  FLastTickIPv6;
    property     LastDTIPv4: TDateTime              read  FLastDTIPv4;
    property     LastDTIPv6: TDateTime              read  FLastDTIPv6;
  published
    { Published declarations }
    property AliveMethod: TAliveMethod              read  FAliveMethod
                                                    write FAliveMethod;
    property AliveNets: TAliveNetwork               read  FAliveNets
                                                    write FAliveNets;
    property HostIPv4: string                       read  FHostIPv4
                                                    write FHostIPv4;
    property HostIPv6: string                       read  FHostIPv6
                                                    write FHostIPv6;
    property HttpPage: string                       read  FHttpPage
                                                    write FHttpPage;
    property HttpText: string                       read  FHttpText
                                                    write FHttpText;
    property HttpProxy: string                      read  FHttpProxy
                                                    write FHttpProxy;
    property LocalIPv4: string                      read  FLocalIPv4
                                                    write FLocalIPv4;
    property LocalIPv6: string                      read  FLocalIPv6
                                                    write FLocalIPv6;
    property AutoStart: Boolean                     read  FAutoStart
                                                    write FAutoStart;
    property OnlineSecs: Integer                    read  FOnlineSecs
                                                    write FOnlineSecs;
    property OfflineSecs: Integer                   read  FOfflineSecs
                                                    write FOfflineSecs;
    property PingHops: Integer                      read  FPingHops
                                                    write FPingHops;
    property PingMaxSecs: Integer                   read  FPingMaxSecs
                                                    write FPingMaxSecs;
    property PingCheckAddr: Boolean                 read  FPingCheckAddr
                                                    write FPingCheckAddr;
    property FailedWaitSecs: Integer                read  FFailedWaitSecs
                                                    write FFailedWaitSecs;
    property DebugLevel: THttpDebugLevel            read  FDebugLevel
                                                    write FDebugLevel;
    property OnAliveChange: TNotifyEvent            read  FOnAliveChange
                                                    write FOnAliveChange;
    property OnAliveProg: THttpRestProgEvent        read  FOnAliveProg
                                                    write FOnAliveProg;
  end;

{ Retrieve a single value by name out of an URL encoded data stream.        }
function IcsExtractURLEncodedValue(
    Msg         : PChar;            { URL Encoded stream                    }
    Name        : String;           { Variable name to look for             }
    var Value   : String;           { Where to put variable value           }
    SrcCodePage : LongWord = CP_ACP;{ D2006 and older CP_UTF8 only          }
    DetectUtf8  : Boolean  = TRUE)
    : Boolean; overload;

function IcsExtractURLEncodedValue(
    const Msg   : String;           { URL Encoded stream                     }
    Name        : String;           { Variable name to look for              }
    var Value   : String;           { Where to put variable value            }
    SrcCodePage : LongWord = CP_ACP;{ D2006 and older CP_UTF8 only          }
    DetectUtf8  : Boolean  = TRUE)
    : Boolean; overload;

function IcsShellExec(aFile: String; var PID: LongWord): Boolean; overload;
function IcsShellExec(aFile: String): Boolean; overload;

//function IcsEscapeJson(const AStr: AnsiString): AnsiString;  { V8.66 renamed and made public }

{$ENDIF USE_SSL}

implementation

{$IFDEF LINUX}
uses FMUX.Api;                { V8.65 for FmuxOpenUrl }
{$ENDIF}

{$IFDEF USE_SSL}

{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ borrowed from OverbyteIcsHttpSrv and renamed to avoid conflicts }
{ Retrieve a single value by name out of an URL encoded data stream         }
{ In the stream, every space is replaced by a '+'. The '%' character is     }
{ an escape character. The next two are 2 digits hexadecimal codes ascii    }
{ code value. The stream is constitued by name=value couples separated      }
{ by a single '&' character. The special characters are coded by the '%'    }
{ followed by hex-ascii character code.                                     }
function IcsExtractURLEncodedValue(
    Msg         : PChar;    { URL Encoded stream                     }
    Name        : String;   { Variable name to look for              }
    var Value   : String;   { Where to put variable value            }
    SrcCodePage : LongWord; { D2006 and older CP_UTF8 only           }
    DetectUtf8  : Boolean)
    : Boolean;              { Found or not found that's the question }
var
    NameLen  : Integer;
    FoundLen : Integer; {tps}
    Ch       : AnsiChar;
    P, Q     : PChar;
    U8Str    : AnsiString;
begin
    Result  := FALSE;
    Value   := '';
    if Msg = nil then         { Empty source }
        Exit;

    NameLen := Length(Name);
    U8Str := '';
    P := Msg;
    while P^ <> #0 do begin
        Q := P;
        while (P^ <> #0) and (P^ <> '=') do
            Inc(P);
        FoundLen := P - Q; {tps}
        if P^ = '=' then
            Inc(P);
        if (StrLIComp(Q, @Name[1], NameLen) = 0) and
           (NameLen = FoundLen) then begin  {tps}
            while (P^ <> #0) and (P^ <> '&') do begin
                Ch := AnsiChar(Ord(P^)); // should contain nothing but < ord 128
                if Ch = '%' then begin
                    if P[1] <> #0 then    // V1.35 Added test
                        Ch := AnsiChar(htoi2(P + 1));
                    Inc(P, 2);
                end
                else if Ch = '+' then
                    Ch := ' ';
                U8Str := U8Str + Ch;
                Inc(P);
            end;
            Result := TRUE;
            break;
         end;
         while (P^ <> #0) and (P^ <> '&') do
             Inc(P);
        if P^ = '&' then
            Inc(P);
    end;
    if (SrcCodePage = CP_UTF8) or (DetectUtf8 and IsUtf8Valid(U8Str)) then
{$IFDEF COMPILER12_UP}
        Value := Utf8ToStringW(U8Str)
    else
        Value := AnsiToUnicode(U8Str, SrcCodePage);
{$ELSE}
        Value := Utf8ToStringA(U8Str)
    else
        Value := U8Str;
{$ENDIF}
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function IcsExtractURLEncodedValue(
    const Msg   : String;           { URL Encoded stream                    }
    Name        : String;           { Variable name to look for             }
    var Value   : String;           { Where to put variable value           }
    SrcCodePage : LongWord = CP_ACP;{ D2006 and older CP_UTF8 only          }
    DetectUtf8  : Boolean  = TRUE)
    : Boolean; overload;
begin
    Result := IcsExtractURLEncodedValue(PChar(Msg), Name, Value,
                                     SrcCodePage, DetectUtf8);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ run a program, URL or document, returning process handle }
{ beware CoInitializeEx may be needed for some shell extensions }
function IcsShellExec(aFile: String; var PID: LongWord): Boolean;
var
{$IFDEF MSWINDOWS}
    ShellInfo: TShellExecuteInfoW;
{$ENDIF MSWINDOWS}
    WideFileName: WideString;
begin
    PID := 0;
    WideFileName := aFile;
{$IFDEF MSWINDOWS}
    FillChar(Shellinfo, SizeOf(Shellinfo), 0);
    with ShellInfo do begin
        cbSize := SizeOf(TShellExecuteInfo);
        fmask := SEE_MASK_NOCLOSEPROCESS OR
                         SEE_MASK_FLAG_DDEWAIT OR  SEE_MASK_FLAG_NO_UI ;
        Wnd := hInstance;
        lpVerb := 'open';
        lpFile := PWideChar(WideFileName);
        nShow :=  SW_NORMAL;
    end ;
    Result := ShellExecuteExW(@shellinfo);
    if Result then PID := ShellInfo.hProcess;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
   Result := False;
    {$IFDEF LINUX}
    try
        FmuxOpenUrl(PChar(WideFileName));  { V8.65 }
        Result := True;
    except
    end;
  {$ENDIF LINUX}
  {$IFDEF MACOS}
  {$MESSAGE 'TODO ShellExec MACOS'}
  {$ENDIF MACOS}
{$ENDIF POSIX}
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ run a program, URL or document }
function IcsShellExec(aFile: String): Boolean;
var
    PID: LongWord;
begin
    Result := IcsShellExec(aFile, PID);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ TSslHttpRest }
{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
constructor TSslHttpRest.Create(Aowner:TComponent);
begin
    inherited create(AOwner);
    FRequestVer := '1.1';
    FRestParams := TRestParams.Create(self);
    FPostStream := TMemoryStream.Create;
    FResponseStream := TMemoryStream.Create;
    FMaxBodySize := DefMaxBodySize;
 // winsock bug fix for fast connections
    CtrlSocket.ComponentOptions := [wsoNoReceiveLoop];
    SocketFamily := sfAny;         { V8.60 allow IPv6 or IPv4 }
    Options := Options + [httpoEnableContentCoding];
    FSslSessCache := true;
    FExternalSslSessionCache := nil;
    RestCookies := TIcsCookies.Create(self);
    RestCookies.OnNewCookie := onCookiesNewCookie;
{$IFNDEF NO_DEBUG_LOG}
    RestLogger := TIcsLogger.Create (nil);
    RestLogger.OnIcsLogEvent := IcsLogEvent;
    RestLogger.LogOptions := [loDestEvent];
    IcsLogger := RestLogger;
{$ENDIF}
    RestSslCtx := TSslContext.Create(self) ;
    SslContext := RestSslCtx;
    RestSslCtx.SslVerifyPeer := false ;
{$IFNDEF NO_DEBUG_LOG}
    RestSslCtx.IcsLogger := RestLogger;
{$ENDIF}
    FSslCliCert := TX509Base.Create(self);
    FCertVerMethod := CertVerNone;
    FSslRootFile := 'RootCaCertsBundle.pem';  // blank will use internal bundle
    FSslCliSecurity := sslCliSecTls12;
    FDebugLevel := DebugSsl;
    FRespReq := False;
    FInitSsl := false;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
destructor TSslHttpRest.Destroy;
begin
    FreeAndNil(FRestParams);
    FreeAndNil(FPostStream);
    FreeAndNil(FResponseStream);
{$IFDEF MSWINDOWS}
    FreeAndNil(FMsCertChainEngine);
{$ENDIF MSWINDOWS}
    FreeAndNil(FExternalSslSessionCache);
    FreeAndNil(RestSslCtx);
    FreeAndNil(FSslCliCert);
{$IFNDEF NO_DEBUG_LOG}
    FreeAndNil(RestLogger) ;
{$ENDIF}
    FreeAndNil(RestCookies);
    inherited Destroy;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.InitSsl;
var
    rootfname: String;
begin
    if FInitSsl then Exit;
{$IFNDEF NO_DEBUG_LOG}
    if FDebugLevel >= DebugSslLow then
        RestLogger.LogOptions := RestLogger.LogOptions + [loSslInfo, loProtSpecInfo];
{$ENDIF}

    if not Assigned (FExternalSslSessionCache) then begin
        FExternalSslSessionCache := TSslAvlSessionCache.Create (self);
 //       fExternalSslSessionCache.AdjustTimeout := True;
 //       fExternalSslSessionCache.SessionTimeOut := 30;
 //       fExternalSslSessionCache.FlushInterval := 3000;
    end;
    RestSslCtx.SslOptions2 := RestSslCtx.SslOptions2 +
       [sslOpt2_NO_SESSION_RESUMPTION_ON_RENEGOTIATION, sslOpt2_NO_RENEGOTIATION];
    RestSslCtx.SslECDHMethod := sslECDHAuto;
    RestSslCtx.SslCipherList := sslCiphersNoDH;     { V8.66 }
    RestSslCtx.SslCliSecurity := FSslCliSecurity;

  // see if verifying server SSL certificate
    if (FCertVerMethod > CertVerNone) then begin
        RestSslCtx.SslVerifyPeer := true;
        RestSslCtx.SslVerifyPeerModes := [SslVerifyMode_PEER];
        RestSslCtx.SslSessionCacheModes := [sslSESS_CACHE_CLIENT];
        if fSslSessCache then begin
            RestSslCtx.SslSessionCacheModes := [sslSESS_CACHE_CLIENT,
                sslSESS_CACHE_NO_INTERNAL_LOOKUP, sslSESS_CACHE_NO_INTERNAL_STORE] ;
        end;
    end ;
    try
        if NOT RestSslCtx.IsCtxInitialized then begin
            RestSslCtx.InitContext;
            if FDebugLevel >= DebugSslLow then begin
               if NOT GSSLStaticLinked  then          { V8.66 }
                    LogEvent('SSL Version: ' + OpenSslVersion + ', Dir: ' + GLIBEAY_DLL_FileName)
                else
                    LogEvent('SSL Statically Linked Version : ' + OpenSslVersion);
            end;
        end;
        FInitSsl := True;
    except
        on E:Exception do
        begin
            LogEvent('Error Starting SSL: ' + E.Message);
        end;
    end;

 // V8.62 can not load bundle until context exists
    if (FCertVerMethod >= CertVerBundle) then begin
        rootfname := fSslRootFile;
        if rootfname <> '' then begin
            if (Pos (':', rootfname) = 0) then
                rootfname := ExtractFileDir (ParamStr (0)) + '\' + rootfname ;
            if NOT FileExists (rootfname) then  begin
                LogEvent('Can Not Find SSL CA Bundle File - ' + rootfname);
                RestSslCtx.LoadCAFromString(sslRootCACertsBundle);  { V8.63 }
            end
            else
                RestSslCtx.SslCAFile := rootfname;
        end
        else
            RestSslCtx.LoadCAFromString(sslRootCACertsBundle);  { V8.63 }
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.SetSslCliSecurity(Value: TSslCliSecurity);
begin
    if Value = FSslCliSecurity then Exit;
    FSslCliSecurity := Value;
    RestSslCtx.SslCliSecurity := FSslCliSecurity;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.ResetSsl;
begin
    FInitSsl := False;
    if FConnected then CloseAsync;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.SetRestParams(Value: TRestParams);
begin
    FRestParams.Assign(Value);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.SetSslCliCert(Value: TX509Base);
begin
    FSslCliCert.Assign(Value);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.LogEvent(const Msg : String);
begin
    if FDebugLevel = DebugNone then Exit;
    if Assigned(FonHttpRestProg) then
        FonHttpRestProg(Self, loProtSpecInfo, Msg) ;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.IcsLogEvent(Sender: TObject; LogOption: TLogOption;
                                                      const Msg : String);
begin
    if Assigned(FonHttpRestProg) then
        FonHttpRestProg(Self, LogOption, Msg) ;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TriggerCommand(var S: String);    { V8.61 }
begin
    Inherited TriggerCommand(S);
    if FDebugLevel >= DebugHdr then
        LogEvent ('> ' + S) ;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TriggerHeaderData;   { V8.61 }
begin
    Inherited TriggerHeaderData;
    if FDebugLevel >= DebugHdr then
        LogEvent ('< ' + LastResponse) ;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TriggerLocationChange;   { V8.61 }
begin
    Inherited TriggerLocationChange;
  { cookies may have been sent during redirection, so update again now }
    FCookie := RestCookies.GetCookies(FLocation);

    if FDebugLevel >= DebugConn then
        LogEvent('= ' + FURL + ' Redirected to: ' + FLocation);
    if Assigned(FOnRestLocChange) then
        FOnRestLocChange(Self);
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TriggerDocBegin;   { V8.61 }
begin
    Inherited TriggerDocBegin;
    if FRespReq and (FContentLength > FMaxBodySize) then begin
        LogEvent('Aborting connection, Body Size too Large: ' + IntToKbyte(FContentLength));
        Abort;
    end;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TriggerCookie(const Data : String; var   bAccept : Boolean); { V8.61 }
begin
    Inherited TriggerCookie(Data, bAccept);
    RestCookies.SetCookie(Data, FURL);
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ triggered even if session is keep-alive }
procedure TSslHttpRest.TriggerSessionConnected;   { V8.61 }
var
    S: String;
begin
    Inherited TriggerSessionConnected;
    if FDebugLevel >= DebugConn then begin
        if FState = httpConnected then begin   { V8.60  }
            S := 'Connected OK to';
            if (FProxy <> '') or  (FSocksServer <> '') then    { V8.62 }
                S := S + ' Proxy';
        end
        else
            S := 'Connection failed to';
        S := S + ': ' + FPunyCodeHost + ' (' + IcsFmtIpv6Addr(AddrResolvedStr) + ')';    { V8.64 }
        LogEvent (S) ;
  {      if FDebugLevel >= DebugHdr then LogEvent ('TCP Buffer Sizes, Send: ' +
                           IntToStr(FCtrlSocket.SocketSndBufSize) +
                              ', Recv: ' + IntToStr(FCtrlSocket.SocketRcvBufSize));  { V8.65 }
    end;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TriggerSessionClosed;   { V8.61 }
begin
    Inherited TriggerSessionClosed;
    if FDebugLevel >= DebugConn then
        LogEvent ('Connection closed') ;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TransferSslVerifyPeer(Sender        : TObject;
                                    var Ok        : Integer;
                                    Cert           : TX509Base);  { V8.61 }
begin
    Inherited TransferSslVerifyPeer(Sender, OK, Cert);
    OK := 1; // don't check certificate until handshaking over
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TransferSslCliGetSession(Sender      : TObject;
                                   var SslSession  : Pointer;
                                  var FreeSession  : Boolean);  { V8.61 }
begin
    Inherited TransferSslCliGetSession(Self, SslSession, FreeSession);
    { SslCliNewSession/SslCliGetSession allow external, client-side session }
    { caching.                                                              }
    if not fSslSessCache then Exit;
    if FDebugLevel >= DebugSslLow then
        LogEvent ('Check for Old SSL Session');
    SslSession := fExternalSslSessionCache.GetCliSession(FCtrlSocket.PeerAddr +
                                                    FCtrlSocket.PeerPort, FreeSession);
    if FDebugLevel < DebugSslLow then Exit;
     if Assigned (SslSession) then
        LogEvent ('Old SSL Session Found Cached')
    else
        LogEvent ('No Old SSL Session Cached');
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TransferSslCliNewSession(Sender      : TObject;
                                      SslSession   : Pointer;
                                      WasReused    : Boolean;
                                  var IncRefCount  : Boolean);  { V8.61 }
begin
    Inherited TransferSslCliNewSession(Sender, SslSession, WasReused, IncRefCount);
    { SslCliNewSession/SslCliGetSession allow external, client-side session }
    { caching.                                                              }
    if not fSslSessCache then Exit;
    if FDebugLevel >= DebugSslLow then
        LogEvent ('Starting SSL Session');
    if (not WasReused) then begin
        fExternalSslSessionCache.CacheCliSession(SslSession,
                        FCtrlSocket.PeerAddr + FCtrlSocket.PeerPort, IncRefCount);
        if FDebugLevel >= DebugSslLow then
             LogEvent ('Cache SSL Session: New');
    end
    else begin
        if FDebugLevel >= DebugSslLow then
            LogEvent ('Cache SSL Session: Reuse');
    end;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TransferSslHandshakeDone(         { V8.61 }
    Sender         : TObject;
    ErrCode        : Word;
    PeerCert       : TX509Base;
    var Disconnect : Boolean);
var
    CertChain: TX509List;
{$IFDEF MSWINDOWS}
    ChainVerifyResult: LongWord;
{$ENDIF MSWINDOWS}
    info, host, VerifyInfo: String;
    Safe: Boolean;
    HttpCtl: TWSocket;
begin
    Inherited TransferSslHandshakeDone(Sender, ErrCode, PeerCert, Disconnect);
    HttpCtl := (Sender as TSslHttpCli).CtrlSocket ;

  // !!! V8.66 temp diags
//    LogEvent('!!! SSL Handshake CertVerify, Err=' + IcsX509VerifyErrorToStr(HttpCtl.SslVerifyResult));

  // nothing much to do if SSL failed or event said disconnect
    if (ErrCode <> 0) or Disconnect then begin
        FReasonPhrase := HttpCtl.SslServerName + ' SSL Handshake Failed: ' + HttpCtl.SslHandshakeRespMsg;
        LogEvent (FReasonPhrase) ;
        exit;
    end  ;
    if FDebugLevel >= DebugSsl then
        LogEvent (HttpCtl.SslServerName + ' ' + HttpCtl.SslHandshakeRespMsg) ;
    if HttpCtl.SslSessionReused OR (FCertVerMethod = CertVerNone) then begin
        exit; // nothing to do, go ahead
    end ;

 // Property SslCertChain contains all certificates in current verify chain
    CertChain := HttpCtl.SslCertChain;

 // see if validating against Windows certificate store - V8.65 only for Windows
    if FCertVerMethod = CertVerWinStore then begin
{$IFDEF MSWINDOWS}
        // start engine
        if not Assigned (FMsCertChainEngine) then
            FMsCertChainEngine := TMsCertChainEngine.Create;

      // see if checking revoocation, CRL checks and OCSP checks in Vista+, very slow!!!!
        if fSslRevocation then
            FMsCertChainEngine.VerifyOptions := [mvoRevocationCheckChainExcludeRoot]
        else
            FMsCertChainEngine.VerifyOptions := [];

        // This option doesn't seem to work, at least when a DNS lookup fails
        FMsCertChainEngine.UrlRetrievalTimeoutMsec := 10000;

        { Pass the certificate and the chain certificates to the engine      }
        FMsCertChainEngine.VerifyCert (PeerCert, CertChain, ChainVerifyResult, True);

        Safe := (ChainVerifyResult = 0) or
                { We ignore the case if a revocation status is unknown.      }
                (ChainVerifyResult = CERT_TRUST_REVOCATION_STATUS_UNKNOWN) or
                (ChainVerifyResult = CERT_TRUST_IS_OFFLINE_REVOCATION) or
                (ChainVerifyResult = CERT_TRUST_REVOCATION_STATUS_UNKNOWN or
                                     CERT_TRUST_IS_OFFLINE_REVOCATION);

       { The MsChainVerifyErrorToStr function works on chain error codes     }
        VerifyInfo := MsChainVerifyErrorToStr (ChainVerifyResult);

    // MSChain ignores host name, so see if it failed using OpenSSL
        if PeerCert.VerifyResult = X509_V_ERR_HOSTNAME_MISMATCH then begin
            Safe := False;
            VerifyInfo := PeerCert.FirstVerifyErrMsg;
        end;
{$ELSE}
        LogEvent ('Windows certificate store not available');  { V8.65 }
        exit ;
{$ENDIF MSWINDOWS}
    end
    else if FCertVerMethod = CertVerBundle then begin
        VerifyInfo := PeerCert.FirstVerifyErrMsg;
        Safe := (PeerCert.VerifyResult = X509_V_OK);   { check whether SSL chain verify result was OK }
    end
    else begin
        exit ;  // unknown method
    end ;

   // see if allowing self signed
   if (PeerCert.VerifyResult = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN) and
                                        FSslAllowSelfSign then Safe := True;

  // tell user verification failed
    if NOT Safe then begin
        info := 'SSL Chain Verification Failed: ' + VerifyInfo + ', Domain: ';
        if PeerCert.SubAltNameDNS = '' then
            host := IcsUnwrapNames(PeerCert.SubjectCName)
        else
            host := IcsUnwrapNames(PeerCert.SubAltNameDNS);
        info := info + host;
        if host <> HttpCtl.SslServerName then  { V8.62 only expected if different }
            info := info + ', Expected: ' + HttpCtl.SslServerName;
        if FDebugLevel >= DebugSsl then
            LogEvent (info);
        FReasonPhrase := info;  { V8.58 }
    end
    else begin
        if FDebugLevel >= DebugSsl then
           LogEvent (HttpCtl.SslServerName + ' SSL Chain Verification Succeeded') ;
    end;

  // if certificate checking failed, see if the host is specifically listed as being allowed anyway
    if (NOT Safe) and (SslAcceptableHosts.IndexOf (HttpCtl.SslServerName) > -1) then begin
        Safe := true ;
        if FDebugLevel >= DebugSsl then
            LogEvent (HttpCtl.SslServerName + ' SSL Succeeded with Acceptable Host Name') ;
    end ;

  // tell user about all the certificates we found
    if (FDebugLevel >= DebugSsl) and fSslReportChain and (CertChain.Count > 0) then  begin
        info := HttpCtl.SslServerName + ' ' + IntToStr (CertChain.Count) +
                ' SSL Certificates in the verify chain:' + #13#10 +
                    CertChain.AllCertInfo (true, true) + #13#10 ; // Mar 2017 report all certs, backwards
        if FDebugLevel >= DebugSsl then
            LogEvent (info);
    end;

  // all failed, V8.65 need to remove cached SSL session so it's not reused!!!
    if NOT Safe then begin
        Disconnect := TRUE;
        if fSslSessCache then begin
            if fExternalSslSessionCache.RemoveSession(HttpCtl.PeerAddr + HttpCtl.PeerPort) then
                LogEvent('SSL Session Uncached After Failure')
            else
                LogEvent('SSL Session Not Found in Cache');
        end;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TransferSslCliCertRequest(Sender: TObject; var Cert: TX509Base);  { V8.61 }
begin
    Inherited TransferSslCliCertRequest(Sender, Cert);
    if FSslCliCert.IsCertLoaded then begin
        Cert := FSslCliCert;
        if FDebugLevel >= DebugSsl then
            LogEvent('Client SSL Certificate Sent') ;
    end
    else
        LogEvent('No Client SSL Certificate to Send') ;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.onCookiesNewCookie(Sender : TObject; ACookie : TCookie;
    var Save : Boolean);
var
    S : String;
begin
    if FDebugLevel < DebugParams then Exit;

 // tell user what cookie was saved, optional
    with ACookie do begin
        S := 'NewCookie: ' + CName + '=' + CValue + ', Domain=' + CDomain + ', Path=' + CPath;
        if CPersist then
            S := S + ', Expires=' + DateTimeToStr(CExpireDT)
        else
            S := S + ', Not Persisent';
        if CSecureOnly then
            S := S + ', SecureOnly';
        if CHttpOnly then
            S := S + ', HttpOnly';
        LogEvent(S);
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TSslHttpRest.GetParams: AnsiString;  { V8.64 lost reqtype }
begin
    Result := '';
    if (FRestParams.Count > 0) then begin
        Result := FRestParams.GetParameters;
    { V8.64 use PContBodyJson for POST, set automatically in RestRequest }
        if (FRestParams.PContent = PContJson) then  // must flatten Json for GET/PUT
            Result:= IcsBase64UrlEncodeA(Result);
        if (FRestParams.PContent = PContBodyJson) then   { V8.61 added UTF8 }
                FContentPost := 'application/json; charset=UTF-8'
        else if (FRestParams.PContent = PContBodyUrlEn) then   { V8.61 added UTF8 }
                FContentPost := 'application/x-www-form-urlencoded; charset=UTF-8'
        else if (FRestParams.PContent = PContBodyXML) then   { V8.61 added UTF8 }
                FContentPost := 'application/xml; charset=UTF-8';
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TSslHttpRest.GetResponseJson: ISuperObject;
var
    ErrStr: String;
begin
    Result := Nil;
    if NOT Assigned(FResponseJson) and (FResponseRaw <> '') then begin
        try
         { V8.65 actually get parse errors with new function rather than ignoring them }
            FResponseJson := TSuperObject.ParseStringEx(PWideChar(FResponseRaw), True, ErrStr);
            if ErrStr <> '' then
                LogEvent('Failed to parse Json response: ' + ErrStr);      { V8.65 }
        except
            on E:Exception do begin
                LogEvent('Failed to parse Json response: ' + E.Message);   { V8.65 }
                FResponseJson := Nil;
                Exit;
            end;
        end;
    end;
    if NOT Assigned (FResponseJson) then       { V8.55 }
        LogEvent('Failed to parse Json response');
    Result := FResponseJson;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TSslHttpRest.GetResponseOctet: AnsiString;
begin
    Result := '';
    if FResponseSize = 0 then Exit;
    FResponseStream.Position := 0; { V8.67 Seek (0, soFromBeginning) ;  }
    SetLength (Result, FResponseSize);
    FResponseStream.Read(Result[1], FResponseSize);
    FResponseStream.Position := 0; { V8.67 Seek (0, soFromBeginning) ; }
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.DoRequestAsync(Rq : THttpRequest); { V8.66 }
begin
    if NOT FInitSsl then InitSsl;   // first call may be legacy GET or PUT
    Inherited DoRequestAsync(Rq);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.TriggerRequestDone2;  { V8.61 }
var
    Info: String;
begin
    Info := FReasonPhrase;
    if FStatusCode > 0 then Info := IntToStr(FStatusCode) + ' ' + Info;
    if FRequestDoneError <> 0 then begin   // ReasonPhrase has description of ErrCode
        LogEvent('Request failed: ' + Info) ;
        FRespReq := False;
    end
    else begin  { V8.58 }
        LogEvent('Request completed: ' + Info);
        try
            if FRespReq then begin  // only process response for REST request
                FRespReq := False;
                FResponseSize := FResponseStream.Size;

                if FResponseSize <> 0 then begin
                    FResponseStream.Position := 0; { V8.67 Seek (0, soFromBeginning) ; }

                  // convert response to correct codepage, including entities
                    if (Pos ('text/', FContentType) = 1) or
                         (Pos ('json', FContentType) <> 0) or
                           (Pos ('javascript', FContentType) <> 0) or  { V8.61 }
                             (Pos ('xml', FContentType) <> 0) then begin
                        FResponseRaw := IcsHtmlToStr(FResponseStream, FContentType, true);
                        FResponseStream.Position := 0; { V8.67 Seek (0, soFromBeginning) ; }
                        if DebugLevel >= DebugBody then
                            LogEvent('Response (length ' + IntToKbyte(Length(FResponseRaw)) +
                                                                  ')' + IcsCRLF +  FResponseRaw);
                    end
                    else if DebugLevel >= DebugBody then
                            LogEvent('Response Non-Textual (length ' + IntToKbyte(FResponseSize));
                end;
            end;
        except
            on E:Exception do
            begin
                LogEvent('Failed to process response: ' + E.Message);
            end;
        end;
    end;
    if Assigned (FOnRestRequestDone) then
        FOnRestRequestDone(Self, FRequestType, FRequestDoneError);
    Inherited TriggerRequestDone2;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSslHttpRest.ClearResp;
begin
    FPostStream.Clear;
    FResponseStream.Clear;
    FResponseJson := Nil;
    FResponseRaw := '';
    FResponseSize := 0;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ make an HTTP request to RestURL.  If RestURL has no parameters (ie ?, except
  POST)) then RawParams are added if not blank, otherwise RestParams are added }
{ V8.64 added ConType for POST/PUT/PATCH body content type }

function TSslHttpRest.RestRequest(HttpRequest: THttpRequest; const RestURL: String;
                    AsyncReq: Boolean = False; const RawParams: String = ''): Integer;
var
    Info: String;
    Params: AnsiString;
begin
    result := -1;
    FReasonPhrase := '';
    ClearResp;
    if (Pos('http', RestURL) <> 1) then begin
        FReasonPhrase := 'Need valid URL: ' + RestURL;
        LogEvent (FReasonPhrase) ;
        Exit;
    end;
    if (FState <> httpReady) then begin
        FReasonPhrase := 'Component is not ready, doing last request';
        LogEvent (FReasonPhrase) ;
        Exit;
    end;
    FRespReq := True;
    InitSsl;
    FSendStream := FPostStream;
    FRcvdStream := FResponseStream;
    FResponseNoException := True;  // stop exception for sync requests
    try
        FURL := RestURL;
        FCookie := RestCookies.GetCookies (RestURL);

    { V8.64 PContent now used to determine if PUT paramaters should be
      be sent as a content body or in the URL, but POST is always body to
      correct PContent if wrong }
        if (HttpRequest = httpPOST) then begin
            if (FRestParams.PContent = PContJson) then
                FRestParams.PContent := PContBodyJson;
            if (FRestParams.PContent = PContUrlencoded) then
                FRestParams.PContent := PContBodyUrlEn;
        end;
        Params := StringToUtf8(RawParams);
        if (Params = '') then Params := GetParams;

     { V8.64 set Json content type if empty }
        if (Params <> '') and (FContentPost = '') then begin
           if (Params[1] = '{') or (Params[1] = '[') then
                FContentPost := 'application/json; charset=UTF-8';  { V8.61 added UTF8 }
        end;

     { V8.64 see if content type means sending a body }
        if (Params <> '') and (FRestParams.PContent in              { V8.65 check some content }
                         [PContBodyJson, PContBodyUrlEn, PContBodyXML]) then begin
            FPostStream.Write(Params[1], Length(Params));
            FPostStream.Position := 0; { V8.67 Seek(0, soFromBeginning) ; }
        end
        else begin
     { V8.64 no content type means URL arguments }
            if (Pos('?', FURL) = 0) and (Params <> '') then { V8.65 not for blank params }
                FURL := RestURL + '?' + String(Params);
        end;
        if HttpRequest = httpGET then Info := 'GET '
        else if HttpRequest = httpHEAD then Info := 'HEAD '
        else if HttpRequest = httpPOST then Info := 'POST '
        else if HttpRequest = httpPUT then Info := 'PUT '
        else if HttpRequest = httpDELETE then Info := 'DELETE '
        else if HttpRequest = httpPATCH then Info := 'PATCH ';
        Info := Info + RestURL;
        if (FDebugLevel >= DebugParams) and (Params <> '') then
            Info := Info + IcsCRLF + String(Params);
        LogEvent(Info);
        FStatusCode := 0;
        if AsyncReq then
            DoRequestASync(HttpRequest)
        else
            DoRequestSync(HttpRequest);
        Result := FStatusCode;  // only for sync requests
    except
        on E:Exception do begin    { 400/500 no longer come here }
            if FRespReq then  { may have reported in Done }
                LogEvent('Request failed: ' + E.Message);
            Result := FStatusCode;
            if Result = 200 then Result := 0; // not really successful
            FRespReq := False;
        end;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{  TSimpleWebSrv }
{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
constructor TSimpleWebSrv.Create (Aowner: TComponent);
begin
    inherited Create(AOwner);
    FWebServer := TSslWSocketServer.Create(Self);
    FWebServer.SslEnable := false;
    FWebServer.MaxClients := 10;
    FWebServer.Banner := '';
    FWebServer.BannerTooBusy := '';
    FWebServer.ClientClass := TSimpleClientSocket;
    FWebServer.OnClientConnect := ServerClientConnect;
    FWebServer.OnClientDisconnect := ServerClientDisconnect;
    FWebServer.OnBgException := SocketBgException;
    FWebServer.SocketErrs := wsErrFriendly;
{$IFNDEF NO_DEBUG_LOG}
    SrvLogger := TIcsLogger.Create (nil);
    SrvLogger.OnIcsLogEvent := IcsLogEvent;
    SrvLogger.LogOptions := [loDestEvent];
    FWebServer.IcsLogger := SrvLogger;
{$ENDIF}
    FWebSrvIP := ICS_LOCAL_HOST_NAME;   { V8.65 }
    FWebSrvPort := '8080';
    FWebSrvPortSsl := '0';
    FWebSrvHostName := ICS_LOCAL_HOST_NAME;
    FDebugLevel := DebugConn;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
destructor TSimpleWebSrv.Destroy;
begin
{$IFNDEF NO_DEBUG_LOG}
    FreeAndNil(SrvLogger) ;
{$ENDIF}
    FreeAndNil(FWebServer);
    inherited Destroy;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TSimpleWebSrv.StartSrv: boolean ;
var
    S: String;
begin
    Result := False;
    try
{$IFNDEF NO_DEBUG_LOG}
        if FDebugLevel >= DebugSslLow then
            SrvLogger.LogOptions := SrvLogger.LogOptions + [loSslInfo, loProtSpecInfo];
{$ENDIF}
        FWebServer.IcsHosts.Clear;
        FWebServer.IcsHosts.Add;  // only need one host
        with FWebServer.IcsHosts [0] do
        begin
            HostEnabled := True;
            if FWebSrvIP = ICS_LOCAL_HOST_NAME then begin   { V8.65 common }
                BindIpAddr := ICS_LOCAL_HOST_V4;
        //        if IsIPV6Available then
                    BindIpAddr2 := ICS_LOCAL_HOST_V6;
            end
            else begin
                BindIpAddr := FWebSrvIP;
                BindIpAddr2 := FWebSrvIP2;       { V8.65 might need IPv6 as well }
            end;
            HostNames.Text := FWebSrvHostName;
            BindNonPort := atoi(FWebSrvPort);
            if FWebSrvPortSsl <> '0' then begin  { V8.62 support SSL }
                BindSslPort := atoi(FWebSrvPortSsl) ;
                HostTag := 'SimpleServer' ;
                Descr := HostTag;
                SslSrvSecurity := sslSrvSecTls12Less;
                SslCert := IcsTrim(FWebSrvCertBundle);
                SslPassword := IcsTrim(FwebSrvCertPassword);
             {   if Assigned(FOnSimpWebSrvAlpn) then begin
                    CertSupplierProto := SuppProtoAcmeV2;
                    CertChallenge := ChallAlpnSrv;
                    FWebServer.SslCertAutoOrder := true;
                end; }
                FWebServer.RootCA := FWebSrvRootFile;
                S := FWebServer.ValidateHosts(False, False);  // don't stop on error, might be self signed certs }
                LogEvent(S);
            end;
        end;
        FWebServer.ExclusiveAddr := true;
        S := FWebServer.MultiListenEx;    // start listening for incoming connections
        if S = '' then
            Result := True
        else
            LogEvent(S);
    except
        on E:Exception do begin
            LogEvent('Web Server failed to start: ' + E.Message);
        end;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ V8.65 added CloseClients, if don't close we can call from event to stop listening only }
function TSimpleWebSrv.StopSrv(CloseClients: Boolean = True): boolean ;
var
    I: integer;
    StartTick: longword;
begin
    try
        if FWebServer.State <> wsClosed then FWebServer.MultiClose;

     { V8.65 optionally abandon client sessions }
        if CloseClients and (FWebServer.ClientCount > 0) then begin
            for I := 0 to Pred (FWebServer.ClientCount) do begin
                if FWebServer.Client [I].State = wsConnected then
                                          FWebServer.Client [I].Close;
            end ;
        end ;
    except
        on E:Exception do begin
            LogEvent('Web Server failed to stop: ' + E.Message);
        end;
    end;

 // wait five seconds for server to close
    Result := IsRunning;
    if NOT Result then Exit;
    LogEvent('Waiting for Web Server to Stop');  { V8.65 }
    StartTick := IcsGetTickCountX;
    while True do begin
        MessagePump;
        Result := IsRunning;
        if NOT Result then break;
        if IcsElapsedSecs(StartTick) > 5 then break;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TSimpleWebSrv.ListenStates: String;   { V8.62 }
begin
    Result := FWebServer.ListenStates;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSimpleWebSrv.LogEvent(const Msg : String);
begin
    if FDebugLevel = DebugNone then Exit;
    if Assigned(FOnServerProg) then
        FOnServerProg(Self, loProtSpecInfo, Msg) ;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSimpleWebSrv.IcsLogEvent(Sender: TObject; LogOption: TLogOption;
                                                      const Msg : String);
begin
    if Assigned(FOnServerProg) then
        FOnServerProg(Self, LogOption, Msg) ;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TSimpleWebSrv.IsRunning: Boolean;
begin
    Result := (FWebServer.State = wsListening);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSimpleWebSrv.SocketBgException(Sender: TObject;
                          E: Exception; var CanClose: Boolean);
begin
    LogEvent ('Web Server Exception: ' + E.Message) ;
    CanClose := true ;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSimpleWebSrv.ServerClientConnect(Sender: TObject; Client: TWSocketClient; Error: Word);
var
    Cli: TSimpleClientSocket;
begin
    if Error <> 0 then begin
        LogEvent('Server listen connect error: ' + WSocketErrorDesc(Error));  { V8.63 }
        Client.Close;
        exit;
    end;
    if FDebugLevel >= DebugConn then
       LogEvent({RFC3339_DateToStr(Now) + } 'Client Connected from Address ' + IcsFmtIpv6Addr(Client.GetPeerAddr));
    Cli := Client as TSimpleClientSocket;
    Cli.WebSrv := Self;
    Cli.LineMode := false;
    Cli.OnDataAvailable := Cli.CliDataAvailable;
    Cli.OnBgException := SocketBgException;
    Cli.OnSimpWebSrvReq := Self.FOnSimpWebSrvReq;
    Cli.OnClientAlpnChallg := Self.FOnSimpWebSrvAlpn; { V8.64 }
    Cli.Banner := '' ;
    Cli.RecvBufMax := 8096;  // only expecting a request header
    SetLength(Cli.RecvBuffer, Cli.RecvBufMax + 1);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSimpleWebSrv.ServerClientDisconnect(Sender: TObject;
                                 Client: TWSocketClient; Error: Word);
begin
    if FDebugLevel >= DebugConn then
        LogEvent('Client Disconnected') ;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ send local web page }
procedure TSimpleClientSocket.CliSendPage(const Status, ContentType, ExtraHdr, BodyStr: String);
var
    HttpRespHdr: string;
begin
  { create response header }
    HttpRespHdr := 'HTTP/1.0 ' + Status + IcsCRLF +
       'Content-Length: ' + IntToStr(Length(BodyStr)) + IcsCRLF +
       'Connection: close' + IcsCRLF;
    if (ContentType <> '') and (BodyStr <> '') then
        HttpRespHdr := HttpRespHdr + 'Content-Type: ' + ContentType + IcsCRLF;
    if ExtraHdr <> '' then
        HttpRespHdr := HttpRespHdr + ExtraHdr + IcsCRLF;
    HttpRespHdr := HttpRespHdr + IcsCRLF;

  { send header and body }
    if WebSrv.DebugLevel >= DebugHdr then
        WebSrv.LogEvent('Web Server Response:' + IcsCRLF + HttpRespHdr + BodyStr);
    SendStr(HttpRespHdr + BodyStr);
    CloseDelayed;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ create and send response error page }
procedure TSimpleClientSocket.CliErrorResponse(const RespStatus, Msg: string);
var
    BodyStr: string;
begin
    BodyStr := '<HTML><HEAD><TITLE>' + RespStatus + '</TITLE></HEAD>' + IcsCRLF +
            '<BODY>' + IcsCRLF +
            '<H1>' + RespStatus + '</H1>' + Msg + '<P>' + IcsCRLF +
            '</BODY></HTML>' + IcsCRLF;
    CliSendPage(RespStatus, 'text/html', '', BodyStr);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ note based on version from OverbyteIcsProxy but cut down to bare minimum }
procedure TSimpleClientSocket.ParseReqHdr;
var
    Line, Arg: String;
    I, J, K, L, Lines: Integer;
begin
    RequestMethod := httpABORT;
    RequestContentLength := 0;
    RequestHost := '';
    RequestHostName := '';
    RequestHostPort := '';
    RequestPath := '/';
    RequestParams := '';
    RequestReferer := '';
    RequestUserAgent := '';

 { process one line in header at a time }
    if Length(HttpReqHdr) <= 4 then Exit;  // sanity check
    I := 1; // start of line
    Lines := 1;
    for J := 1 to Length(HttpReqHdr) - 2 do begin
        if (HttpReqHdr[J] = IcsCR) and (HttpReqHdr[J + 1] = IcsLF) then begin  // end of line
            if (J - I) <= 2 then continue;  // ignore blank line, usually at start
            Line := Copy(HttpReqHdr, I, J - I);
            K := Pos (':', Line) + 1;
            if Lines = 1 then begin
                if (Pos('GET ', Line) = 1) then RequestMethod := httpGet;
                if (Pos('POST ', Line) = 1) then RequestMethod := httpPost;
                if (Pos('HEAD ', Line) = 1) then RequestMethod := httpHead;
                if (Pos('PUT ', Line) = 1) then RequestMethod := httpPut;
                L := Pos(' ', Line);
                if (L > 0) then Line := Copy(Line, L + 1, 99999); // strip request
                L := Pos(' HTTP/1', Line);
                if (L > 0) then begin
                    RequestPath := Copy(Line, 1, L - 1);
                    L := Pos('?', RequestPath);
                    if (L > 0) then begin
                        RequestParams := Copy(RequestPath, L + 1, 99999);
                        RequestPath := Copy(RequestPath, 1, L - 1);
                    end;
                    L := Pos('://', RequestPath);  // V8.62 look for full URL sent by proxy
                    if (L = 4) or (L = 5) then begin
                        RequestPath := Copy(RequestPath, L + 3, 99999);  // strip http://
                        L := Pos('/', RequestPath);  // start of path
                        if (L > 1) then
                            RequestPath := Copy(RequestPath, L, 999999);  // strip host
                    end;
                end;
            end
            else if (K > 3) then begin
                Arg := IcsTrim(Copy(Line, K, 999)); // convert any arguments we scan to lower case later
                if (Pos('Content-Length:', Line) = 1) then RequestContentLength := atoi64(Arg);
                if (Pos('Host:', Line) = 1) then begin
                    RequestHost := IcsLowerCase(Arg);  { need to separate host and port before punycoding }
                    L := Pos(':', RequestHost);
                    if L > 0 then begin
                        RequestHostName := IcsIDNAToUnicode(Copy(RequestHost, 1, L - 1));  { V8.64 }
                        RequestHostPort := Copy(RequestHost, L + 1, 99);
                        RequestHost := RequestHostName + ':' + RequestHostPort;      { V8.64 }
                    end
                    else begin
                        RequestHostName := IcsIDNAToUnicode(RequestHost); { V8.64 }
                        RequestHostPort := WebSrv.FWebSrvPort;
                        RequestHost := RequestHostName;       { V8.64 }
                    end;
                end;
                if (Pos('Referer:', Line) = 1) then RequestReferer := IcsLowercase(Arg);
                if (Pos('User-Agent:', Line) = 1) then RequestUserAgent := Arg;
            end;
            Lines := Lines + 1;
            I := J + 2;  // start of next line
        end;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TSimpleClientSocket.CliDataAvailable(Sender: TObject; Error: Word);
var
    RxRead, RxCount, LoopCounter, HdrLen: Integer;
    RespCode, Body: string;
begin
    try
        LoopCounter := 0;
        if RecvWaitTot < 0 then RecvWaitTot := 0; // sanity check
        while TRUE do begin
            inc (LoopCounter);
            if (LoopCounter > 100) then Break;    // sanity check
            RxCount := RecvBufMax - RecvWaitTot - 1;
            if RxCount <= 0 then Break;           // sanity check
            RxRead := Self.Receive (@RecvBuffer[RecvWaitTot], RxCount);
            if RxRead <= 0 then Break;            // nothing read
            RecvWaitTot := RecvWaitTot + RxRead;
        end;

      { search for blank line in receive buffer which means we have complete request header }
        HdrLen := IcsTBytesPos(IcsDoubleCRLF, RecvBuffer, 0, RecvWaitTot);
        if (HdrLen <= 0) then begin
            if (WebSrv.DebugLevel >= DebugBody) then
                WebSrv.LogEvent('Waiting for more source data');
            Exit;
        end ;
        HdrLen := HdrLen + 4; // add blank line length

      { keep headers in string so they are easier to process  }
      { ignore any body, don't care about POST requests }
        SetLength(HttpReqHdr, HdrLen);
        IcsMoveTBytesToString(RecvBuffer, 0, HttpReqHdr, 1, HdrLen);

       { see what was sent }
        ParseReqHdr;

       { ask user what we should do next }
        if (RequestMethod = httpGET) and Assigned(OnSimpWebSrvReq) then begin
            RespCode := '';
            try    { V8.65 always send response even if event crashes }
                OnSimpWebSrvReq(Self, RequestHost, RequestPath, RequestParams, RespCode, Body);
            except
                on E:Exception do
                    WebSrv.LogEvent('Error Processing Response: ' + E.Message);
            end;
            if RespCode <> '' then
                CliSendPage(RespCode, 'text/html', '', Body)
            else
                CliErrorResponse('500 Server Error', 'The requested URL ' +
                   TextToHtmlText(RequestPath) + ' was not processed by the server.');
        end
        else begin
            if WebSrv.DebugLevel >= DebugHdr then
                WebSrv.LogEvent({RFC3339_DateToStr(Now) + } 'Server Request Ignored, Host: ' +
                        RequestHost + ', Path: ' + RequestPath + ', Params: ' + RequestParams);   { V8.62 }
            CliErrorResponse('404 Not Found', 'The requested URL ' +
                 TextToHtmlText(RequestPath) + ' was not found on this server.');
        end;
    except
         on E:Exception do
            WebSrv.LogEvent('Error Receive Data: ' + E.Message);
    end ;
end ;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ TRestOAuth }
{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
constructor TRestOAuth.Create (Aowner: TComponent);
begin
    inherited Create(AOwner);
    FWebServer := TSimpleWebSrv.Create(self);
    FWebServer.OnServerProg := WebSrvProg;  { V8.63 got lost somehow }
    FWebServer.OnSimpWebSrvReq := WebSrvReq;
    HttpRest := TSslHttpRest.Create(self);
    HttpRest.OnHttpRestProg := RestProg;
    FWebSrvIP := ICS_LOCAL_HOST_NAME;         { V8.65 }
    FWebSrvPort := '8080';
    FDebugLevel := DebugConn;
    FProtoType := OAuthv2;
    FAuthType := OAuthTypeWeb;
    FRefrMinsPrior := 120;
    FRefreshDT := 0;
    FScope := '';
    FLoginPrompt := 'consent';                { V8.63 }
    FResponseMode := 'query';                 { V8.65 }
    OAuthParams := TRestParams.Create(self);  { V8.65 }
    OAuthParams.PContent := PContUrlencoded;
    OAuthParams.RfcStrict := True;   { Twitter needs strict RFC }
    Randomize;                          { V8.65 }
    FLastWebTick := TriggerDisabled;
    FRefreshTimer := TIcsTimer.Create(HttpRest);
    FRefreshTimer.OnTimer := RefreshOnTimer;
    FRefreshTimer.Interval := TicksPerMinute;
    FRefreshTimer.Enabled := True;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
destructor TRestOAuth.Destroy;
begin
    FRefreshTimer.Enabled := False;
    StopSrv;
    FreeAndNil(FRefreshTimer);
    FreeAndNil(OAuthParams);
    FreeAndNil(HttpRest);
    FreeAndNil(FWebServer);
    inherited Destroy;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TRestOAuth.RestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
begin
    if Assigned(FOnOAuthProg) then
        FOnOAuthProg(Self, LogOption, Msg) ;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TRestOAuth.WebSrvProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
begin
    if Assigned(FOnOAuthProg) then
        FOnOAuthProg(Self, LogOption, 'OAuth Web Server ' + Msg);    { V8.63 }
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TRestOAuth.LogEvent(const Msg : String);
begin
    if FDebugLevel = DebugNone then Exit;
    if Assigned(FOnOAuthProg) then
        FOnOAuthProg(Self, loProtSpecInfo, Msg) ;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TRestOAuth.SetError(ErrCode: Integer; const Msg: String);
begin
    FLastErrCode := ErrCode;
    FLastError := Msg;
    LogEvent(Msg);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TRestOAuth.SetRefreshDT;
begin
    FRefreshDT := 0;
    if FRefreshToken = '' then Exit;
    if (FExpireDT < 10) then Exit;
    if (FRefrMinsPrior < 10) then FRefrMinsPrior := 10;
    FRefreshDT := FExpireDT - ((FRefrMinsPrior * 60) / SecsPerDay);
    if FRefreshAuto then
        LogEvent('Token will Automatically Refresh at: ' + DateTimeToStr(FRefreshDT));
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TRestOAuth.SetExpireDT(Value: TDateTime);
begin
    if Value <> FExpireDT then begin
        FExpireDT := Value;
        SetRefreshDT;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TRestOAuth.SetRefreshAuto(Value: Boolean);
begin
    if Value <> FRefreshAuto then begin
        FRefreshAuto:= Value;
        SetRefreshDT;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TRestOAuth.SetRefreshToken(Value: String);
begin
    if Value <> FRefreshToken then begin
        FRefreshToken := Value;
        SetRefreshDT;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TRestOAuth.LoadAuthUri(AuthUri: TOAuthUri);                           { V8.65 }
var
    I: Integer;
begin
    FAccName := AuthUri.CAccName;
    FConsoleUrl := AuthUri.CConsoleUrl;
    FAppUrl := AuthUri.CAppUrl;
    FReqTokUrl := AuthUri.CReqTokUrl;  { OAuth1A only }
    FRedirectUrl := AuthUri.CRedirectUrl;
    FTokenUrl := AuthUri.CTokenUrl;
    FScope := AuthUri.CScope;
    I := Pos(ICS_LOCAL_HOST_NAME, FRedirectUrl);
    if I = 8 then begin
        FWebSrvIP := ICS_LOCAL_HOST_NAME;
        I := IcsPosEx(':', FRedirectUrl, 9);
        if I > 0 then begin
            FWebSrvPort := Copy(FRedirectUrl, I + 1, 6);
            I := Pos('/', FWebSrvPort);
            if I > 2 then FWebSrvPort := Copy(FWebSrvPort, 1, I - 1);
         end;
     end;
end;

{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TRestOAuth.StartSrv: boolean ;
begin
    FWebServer.DebugLevel := Self.FDebugLevel;
    FWebServer.WebSrvIP := Self.FWebSrvIP;
    FWebServer.WebSrvPort := Self.FWebSrvPort;
    Result := FWebServer.StartSrv;
    FLastWebTick := TriggerDisabled;  { V8.60 don't timeout until request }
    if Result then
        LogEvent('OAuth Web Server Started on: ' + IcsFmtIpv6AddrPort(FWebSrvIP, FWebSrvPort))
    else
        LogEvent('OAuth Web Server Failed to Start');
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TRestOAuth.StopSrv(CloseClients: Boolean = True): boolean ;            { V8.65 }
begin
    FLastWebTick := TriggerDisabled;
    Result := FWebServer.StopSrv(CloseClients);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TRestOAuth.SrvIsRunning: Boolean;
begin
    Result := FWebServer.IsRunning;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TRestOAuth.Close;                                                     { V8.65 }
begin
    if SrvIsRunning then StopSrv;
    if HttpRest.State = httpConnected then HttpRest.Close;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TRestOAuth.RefreshOnTimer(Sender : TObject);
begin
    FRefreshTimer.Enabled := False;
    try
     // auto refresh token
        if FRefreshAuto and (FRefreshToken <> '') and (FRefreshDT <> 0) then begin
            if Now > FRefreshDT then begin
                FRefreshDT := 0;
                LogEvent('Starting Automatic Token Refresh');
                if NOT GrantRefresh then begin
                    LogEvent('Automatic Token Refresh Failed: ' + FLastError);
                end;
            end;
        end;

     // close web server on idle timeout - 30 minutes
        if SrvIsRunning and (IcsElapsedMins(FLastWebTick) > 30) then begin
            FLastWebTick := TriggerDisabled;
            LogEvent('OAuth Web Server Stopping on Idle Timeout');
            StopSrv;
        end;
    finally
        FRefreshTimer.Enabled := True;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ event called by simple web server when any page is requested }
procedure TRestOAuth.WebSrvReq(Sender: TObject; const Host, Path,
                                Params: string; var RespCode, Body: string);
var
    State, Code, Title, Msg, Error, Redirect, ErrorDesc: String;
    oauth_token, oauth_verifier: String;
//    Client: TSimpleClientSocket;

    procedure BuildBody;
    begin
        Body := '<HTML><HEAD><TITLE>' + Title + '</TITLE></HEAD>' + IcsCRLF +
            '<BODY>' + IcsCRLF +
            '<H1>' + Title + '</H1>' + Msg + '<P>' + IcsCRLF +
            '</BODY></HTML>' + IcsCRLF;
        LogEvent('OAuth Web Response: ' + RespCode);
    end;

begin
//    Client := Sender as TSimpleClientSocket;

 // ignore favicon requests completely
    if Path = '/favicon.ico' then begin
        RespCode := '404 Not Found';
        Title := RespCode;
        Msg := 'Error: File Not Found';
        BuildBody;
        Exit;
    end;

    FLastWebTick := IcsGetTickCountX;   // timeout to close server
    LogEvent('OAuth Web Request, Host: ' + Host + ', Path: ' + Path + ', Params: ' + Params);
    Redirect := 'http://' + Host + Path;
    if Redirect <> FRedirectUrl then
        LogEvent('Warning, Differing Redirect URL: ' + Redirect);

  // for an OAuth authentication redirect, we don't really care about the path
    IcsExtractURLEncodedValue (Params, 'state', State) ;   // OAuth2
    IcsExtractURLEncodedValue (Params, 'code', Code) ;     // OAuth2
    IcsExtractURLEncodedValue (Params, 'error', Error) ;   // OAuth2
    IcsExtractURLEncodedValue (Params, 'oauth_token', oauth_token) ;       // OAuth1a
    IcsExtractURLEncodedValue (Params, 'oauth_verifier', oauth_verifier) ; // OAuth1a
    IcsExtractURLEncodedValue (Params, 'error_description', ErrorDesc);   // OAuth2 V8.65

  // V8.65 OAuth1A check expected request token, keep code
    if (FProtoType = OAuthv1A) then begin
        if (oauth_token <> FReqToken) and (oauth_verifier = '') then begin
            RespCode := '501 Internal Error';
            Title := 'OAuth Authorization Failed';
            Msg := 'Error: No OAuth1 Tokens Found';
            BuildBody;
            Exit;
        end;
        FAuthCode := oauth_verifier;
    end

  // OAuth2
    else begin
        if (Error <> '') then begin
            StopSrv(False);  { V8.65 stop server listening on error, don't close client }
            RespCode := '501 Internal Error';
            Title := 'OAuth Authorization Failed';
            Msg := 'Error: ' + Error + '<P>' + IcsCRLF + ErrorDesc;
            BuildBody;
            Exit;
        end;

        if (NOT (OAopAuthNoState in FOAOptions)) and
                (State = '') or (State <> FRedirState)  then begin
            StopSrv(False);  { V8.65 stop server listening on error, don't close client }
            RespCode := '501 Internal Error';
            Title := RespCode;
            Msg := 'Error: Unexpected State';
            BuildBody;
            Exit;
        end;

        if (Code = '') then begin
            StopSrv(False);  { V8.65 stop server listening on error, don't close client }
            RespCode := '501 Internal Error';
            Title := RespCode;
            Msg := 'Error: Can not find Authorization Code';
            BuildBody;
            Exit;
        end;
        FAuthCode := Code;
    end;

 // if not testing, save new code. try and get token
    Title := 'Authorization Code Generated Successfully';
    LogEvent('OAuth Web Request, ' + Title + ', ' + Code);  { V8.65 }
    Msg := '<p><b>App Authorization Code: ' + Code + '</b></p>' + IcsCRLF +
            '<b>' + FRedirectMsg + '</b></p>';
    RespCode := '200 OK';
    if FRedirState <> TestState then begin
        if Assigned(FOnOAuthNewCode) then
            FOnOAuthNewCode(Self);
        LogEvent('OAuth Web Request, Getting New Token');  { V8.65 }
        if GrantAuthToken(FAuthCode) then begin
            Title := 'App Token Generated Successfully';
            Msg := '<p><b>App Token Generated Successfully</b></p>' + IcsCRLF +
            '<b>' + FRedirectMsg + '</b></p>';
        end
        else
            Title := 'Failed to Generate App Token';
    end;
    BuildBody;
  { web page is sent by event handler }
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TRestOAuth.TestRedirect: boolean;
var
    StatCode: Integer;
begin
    Result := false;
    FLastErrCode := OAuthErrNoError;
    FLastError := '';
    if NOT SrvIsRunning then
        StartSrv;
    if NOT SrvIsRunning then begin
        SetError(OAuthErrWebSrv, 'Can Not Test Redirect, Web Server Will Not Start');
        Exit;
    end;
    if Pos ('http://', FRedirectUrl) <> 1 then begin
        SetError(OAuthErrParams, 'Can Not Test Redirect, Invalid Redirect URL');
        Exit;
    end;
    FRedirState := TestState;
    HttpRest.Reference := FRedirectUrl;
    HttpRest.DebugLevel := FDebugLevel;
    HttpRest.RestParams.Clear;
    HttpRest.RestParams.AddItem('state', FRedirState);
    HttpRest.RestParams.AddItem('code', '12345678901234567890');
    StatCode := HttpRest.RestRequest(HttpGET, FRedirectUrl, False, '');
    if StatCode <> 200 then
        SetError(OAuthErrWebSrv, 'Test Redirect Failed')
     else begin
        LogEvent('Test Redirect OK');
        Result := true;
    end;
    StopSrv(False);  { V8.65 close server but not current client }
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TRestOAuth.GetNonce: String;                                      { V8.65 }
var
    I: Integer;
begin
    Result := '';
    for I := 1 to 16 do
        Result := Result + Chr(Random(26) + Ord('A')) + Chr(Random(26) + Ord('a'));
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ OAuth1A get SHA1 digest of request, URL and parameters, Base String }
{ OAuthParams may already have items }
{ everything strictly percent URL encooded according to RTF, in alpha order }
function TRestOAuth.GetOAuthSignature(const Req, Url: String; ReqTok: Boolean = False): String;    { V8.65 }
var
    SignBase, SignKey, Params: AnsiString;
begin
    SignKey := UrlEncodeToA(FClientSecret, CP_UTF8, True) + IcsAmpersand;
    OAuthParams.AddItem('oauth_consumer_key', FClientId);
    OAuthParams.AddItem('oauth_nonce', GetNonce);
    OAuthParams.AddItem('oauth_signature_method', 'HMAC-SHA1');
    OAuthParams.AddItem('oauth_timestamp', IntToStr(IcsGetUnixTime));
    if ReqTok then begin
        OAuthParams.AddItem('oauth_token', FReqToken);
        if FReqTokSecret <> '' then
          SignKey := SignKey + UrlEncodeToA(FReqTokSecret, CP_UTF8, True);
    end
    else begin
        OAuthParams.AddItem('oauth_token', FAccToken);
        if FAccTokSecret <> '' then
          SignKey := SignKey + UrlEncodeToA(FAccTokSecret, CP_UTF8, True);
    end;
    OAuthParams.AddItem('oauth_version', '1.0');
    OAuthParams.PContent := PContUrlencoded;
    Params := OAuthParams.GetParameters(True);  // sorted name order or hash fails
 // parameters are urlencoded a second time so only two & in signbase
    SignBase := AnsiString(IcsUpperCase(Req)) + IcsAmpersand +
                   UrlEncodeToA(Url, CP_UTF8, True) +
                        IcsAmpersand + UrlEncodeToA(String(Params), CP_UTF8, True);
    Result := String(Base64Encode(IcsHMACDigestEx(SignBase, SignKey, Digest_sha1)));
    LogEvent('OAuth1 Params: ' + String(Params) + IcsCRLF +
             'SignBase: ' + String(SignBase) +  IcsCRLF +
             'SignKey; ' + String(SignKey) + IcsCRLF +
             'Signature: ' + Result);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ Launch browser with console or account URL }
function TRestOAuth.LaunchConsole: boolean;
begin
    Result := False;
    if FConsoleUrl = '' then begin
        SetError(OAuthErrParams, 'Can Not Launch Browser, Invalid Redirect URL');
        Exit;
    end;
    if IcsShellExec(FConsoleUrl) then begin
        LogEvent('Launched Browser to console: ' + FConsoleUrl);
        Result := True;
    end
    else begin
        SetError(OAuthErrBrowser, 'Failed to Launch Browser: ' + GetWindowsErr(GetLastError));
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ Start user authorisation generally using a browser to enter a login, which
   then redirects back to a local web server which gets the authorisation code }
function TRestOAuth.StartAuthorization: boolean;
var
    BrowserURL, Signature, CallBackOK, S: string;
    StatCode: Integer;
    ErrJson: ISuperObject;
begin
    Result := false;
    FLastErrCode := OAuthErrNoError;
    FLastError := '';
    if (FProtoType = OAuthv1) then begin
        SetError(OAuthErrParams, 'OAuth1 Not Supported');
        Exit;
    end;
    if Pos ('http://', FRedirectUrl) <> 1 then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Invalid Redirect URL: ' + FRedirectUrl);
        Exit;
    end;
    if Pos ('https://', FAppUrl) <> 1 then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Invalid App URL: ' + FAppUrl);
        Exit;
    end;
    if (FClientId = '') or (FClientSecret = '') then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Need Client ID and Secret');
        Exit;
    end;
    HttpRest.DebugLevel := FDebugLevel;          { V8.65 }
    FAccToken := '';                             { V8.65 }
    FExpireDT := 0;                              { V8.65 }

// OAuth1A get request token and build URL for browser
    if (FProtoType = OAuthv1A) then begin
        FReqToken := '';
        FReqTokSecret := '';

    // build base string, used for hashed signature
    // must include POST content and URL paramaters, sorted
        OAuthParams.Clear;
        OAuthParams.AddItem('oauth_callback', FRedirectUrl);
        Signature := GetOAuthSignature('POST', FReqTokUrl, True);   // adds commom parameters

    // adjust base string for Authorization: OAuth header, add signature, leave callback
        OAuthParams.AddItem('oauth_signature', Signature);
        HttpRest.ServerAuth := httpAuthOAuth;
        OAuthParams.PContent := PContCommaList;  // change paramter format
        HttpRest.AuthBearerToken := String(OAuthParams.GetParameters(True)); // bearer is quoted encoded values, comma separated
        LogEvent('Authorization: OAuth ' + HttpRest.AuthBearerToken);

        HttpRest.RestParams.Clear;
        StatCode := HttpRest.RestRequest(httpPOST, FReqTokUrl, False, '');
        if (StatCode <> 200) then begin
            S := HttpRest.ResponseRaw;
            if S = '' then
                S := HttpRest.LastResponse
            else begin
                if Assigned(HttpRest.ResponseJson) then begin
                    ErrJson := HttpRest.ResponseJson.O['errors'];
                    if Assigned(ErrJson) and (ErrJson.AsArray.Length > 0) then
                        S := ErrJson.AsArray.O[0].S['message'];
                end;
            end;
            SetError(OAuthErrParams, 'Can Not Get OAuth1 Request Token: ' + S);
            Exit;
        end
        else begin    // note getting request tokens not access tokens despite the labels!
          // this request does not return Json for some strange reason
            IcsExtractURLEncodedValue (HttpRest.ResponseRaw, 'oauth_token', FReqToken) ;
            IcsExtractURLEncodedValue (HttpRest.ResponseRaw, 'oauth_token_secret', FReqTokSecret) ;
            IcsExtractURLEncodedValue (HttpRest.ResponseRaw, 'oauth_callback_confirmed', CallBackOK) ;
        end;
        if (FReqToken = '') or (FReqTokSecret = '') then begin
            SetError(OAuthErrParams, 'Can Not Find OAuth1 Request Token in Response: ' + HttpRest.ResponseRaw);
            exit;
        end;
        OAuthParams.Clear;
        OAuthParams.PContent := PContUrlencoded;
        OAuthParams.AddItem('oauth_token', FReqToken);
        if (OAopAuthPrompt in FOAOptions) then
            OAuthParams.AddItem('force_login', 'true');
      // OAuthParams.AddItem('screen_name', '??' );     // prefill login name, if we had it
        BrowserURL := FAppUrl + '?' + String(OAuthParams.GetParameters);
   end

// OAuth2 build URL for browser
   else begin
        FRedirState := 'ICS-' + IntToStr(IcsGetTickCountX);
        OAuthParams.Clear;
        OAuthParams.PContent := PContUrlencoded;
        OAuthParams.AddItem('response_type', 'code');
        OAuthParams.AddItem('client_id', FClientId);
        if NOT (OAopAuthNoRedir in FOAOptions) then
            OAuthParams.AddItem('redirect_uri', FRedirectUrl);
        if NOT (OAopAuthNoState in FOAOptions) then
            OAuthParams.AddItem('state', FRedirState);
        if (NOT (OAopAuthNoScope in FOAOptions)) and (FScope <> '') then
            OAuthParams.AddItem('scope', FScope);
        if (OAopAuthPrompt in FOAOptions) and (FLoginPrompt <> '') then
            OAuthParams.AddItem('prompt', FLoginPrompt); { V8.63 none consent select_account }
        if (OAopAuthAccess in FOAOptions) then begin
            if FRefreshOffline then
                OAuthParams.AddItem('access_type', 'offline')   { V8.63 neeed so Google supplies refresh token }
            else
                OAuthParams.AddItem('access_type', 'online');
        end;
//        if FResource <> '' then
//            HttpRest.RestParams.AddItem('resource', FResource);                 { V8.65 }
        if (OAopAuthRespMode in FOAOptions) and (FResponseMode <> '') then
            OAuthParams.AddItem('response_mode', FResponseMode);        { V8.65 }
        if (OAopAuthLoginHint in FOAOptions) and (FLoginHint <> '') then
            OAuthParams.AddItem('login_hint', FLoginHint);              { V8.65 }
        if (OAopAuthGrantedScope in FOAOptions) then
            OAuthParams.AddItem('include_granted_scopes', true); { V8.65 incremental scopes, keep old ones }
        BrowserURL := FAppUrl + '?' + String(OAuthParams.GetParameters);
    end;
    LogEvent('Authorization URL: ' + BrowserURL);

  { various schemes to get authorization code from browser }
  { V8.57 need local web server for all methods }
    if (FAuthType = OAuthTypeWeb) or (FAuthType = OAuthTypeMan) or
                                        (FAuthType = OAuthTypeEmbed) then begin
        if NOT SrvIsRunning then
            StartSrv;
        if NOT SrvIsRunning then begin
            SetError(OAuthErrWebSrv, 'Can Not Start Authorization, Web Server Will Not Start');
            Exit;
        end;
    end;
    if FAuthType = OAuthTypeWeb then begin
        if IcsShellExec(BrowserURL) then begin
            LogEvent('Launched Browser to Login to application, once completed you should see "App Token Generated Successfully"');
            Result := True;
        end
        else begin
            SetError(OAuthErrBrowser, 'Failed to Launch Browser: ' + GetWindowsErr(GetLastError));
        end;
    end
    else if (FAuthType = OAuthTypeMan) or (FAuthType = OAuthTypeEmbed) then begin
        if Assigned (OnOAuthAuthUrl) then begin
            OnOAuthAuthUrl(Self, BrowserURL);
        end;
    end
    else
        SetError(OAuthErrParams, 'Can Not Start Authorization, Unknown Method');
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ get token using HttpRest.RestParams set-up before this call }
function TRestOAuth.GetToken: boolean;
var
    StatCode, secs: Integer;
    Info, Refresh: string;
begin
    Result := false;
    HttpRest.DebugLevel := FDebugLevel;          { V8.65 }
    StatCode := HttpRest.RestRequest(HttpPOST, FTokenUrl, False, '');
    if (StatCode = 0) or (NOT Assigned(HttpRest.ResponseJson)) then  { V8.55 }
        SetError(OAuthErrBadGrant, 'Token Exchange Failed: ' + HttpRest.LastResponse)
     else begin
        FAccToken := HttpRest.ResponseJson.S['access_token'];
        if FAccToken <> '' then begin
            Result := true;
            Refresh := HttpRest.ResponseJson.S['refresh_token'];
            secs := HttpRest.ResponseJson.I['expires_in'];
            FExpireDT := Now + (secs / SecsPerDay);
            FRefreshDT := 0;
            LogEvent('Got New Access Token: ' + FAccToken + IcsCRLF +   { V8.65 two lines }
                            'Which Expires: ' + DateTimeToStr(FExpireDT));

            if (Refresh = '') and (FRefreshToken = '') then
                LogEvent('No Refresh Token Available')
            else if Refresh <> '' then begin   { V8.63 don't kill old refresh if no new token }
                FRefreshToken := Refresh;
                LogEvent('Got New Refresh Token: ' + FRefreshToken);
            end;
        { V8.65 set auto refreesh if old token kept }
            if (FRefreshToken <> '') and FRefreshAuto and
                            (FRefrMinsPrior > 30) and (secs > 300) then begin
                if (secs > (FRefrMinsPrior * 60)) then
                    FRefreshDT := FExpireDT - ((FRefrMinsPrior * 60) / SecsPerDay)
                else
                    FRefreshDT := FExpireDT - (300 / SecsPerDay); // five minutes
                LogEvent('Token will Automatically Refresh at: ' + DateTimeToStr(FRefreshDT));
            end ;
            try
                if Assigned(FOnOAuthNewToken) then
                    FOnOAuthNewToken(Self);
            except
                on E:Exception do
                    SetError(OAuthErrEvent, E.Message);      { V8.65 }
            end;
        end
        else begin
            Info := HttpRest.ResponseJson.S['error'];
            if Info <> '' then
                Info := 'Token Exchange Failed: ' + Info + ' - ' +
                                  HttpRest.ResponseJson.S['error_description']
            else
                Info := 'Token Exchange Failed: REST error: ' + HttpRest.ReasonPhrase;
            SetError(OAuthErrBadGrant, Info);
            LogEvent(HttpRest.ResponseRaw);
        end;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TRestOAuth.GrantAuthToken(const Code: String = ''): boolean;
var
    StatCode: integer;
    Signature, S: string;
    ErrJson: ISuperObject;
begin
    if Code <> '' then FAuthCode := Code;
    Result := false;
    FLastErrCode := OAuthErrNoError;
    FLastError := '';
    if Pos ('http://', FRedirectUrl) <> 1 then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Invalid Redirect URL');
        Exit;
    end;
    if Pos ('https://', FTokenUrl) <> 1 then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Invalid Token URL');
        Exit;
    end;
    if (FAuthCode = '') then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Missing Auth Code');
        Exit;
    end;
    if (FClientId = '') or (FClientSecret = '') then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Need Client ID and Secret');
        Exit;
    end;

  // OAuth1A get access token using request token and oauth_verifier from callback or PIN
    if (FProtoType = OAuthv1A) then begin
    // build base string, used for hashed signature
    // must include POST content and URL paramaters, sorted
        OAuthParams.Clear;
        OAuthParams.AddItem('oauth_callback', FRedirectUrl);
        OAuthParams.AddItem('oauth_verifier', FAuthCode);
        Signature := GetOAuthSignature('POST', FTokenUrl, True);   // adds commom parameters

    // adjust base string for Authorization: OAuth header, add signature, leave callback
        OAuthParams.AddItem('oauth_signature', Signature);
        HttpRest.ServerAuth := httpAuthOAuth;
        OAuthParams.PContent := PContCommaList;  // change paramter format
        HttpRest.AuthBearerToken := String(OAuthParams.GetParameters(True)); // bearer is quoted encoded values, comma separated
        LogEvent('Authorization: OAuth ' + HttpRest.AuthBearerToken);

        HttpRest.RestParams.Clear;
        StatCode := HttpRest.RestRequest(httpPOST, FTokenUrl, False, '');
        if (StatCode <> 200) then begin
            S := HttpRest.ResponseRaw;
            if S = '' then S := HttpRest.LastResponse;
            if FLastError = '' then
                FLastError := HttpRest.LastResponse
            else begin
                if Assigned(HttpRest.ResponseJson) then begin
                    ErrJson := HttpRest.ResponseJson.O['errors'];
                    if Assigned(ErrJson) and (ErrJson.AsArray.Length > 0) then
                        S := ErrJson.AsArray.O[0].S['message'];
                end;
            end;
            SetError(OAuthErrBadGrant, 'Token Exchange Failed: ' + S);
            Exit;
        end
        else begin    // note getting request tokens not access tokens despite the labels!
          // this request does not return Json for some strange reason
            IcsExtractURLEncodedValue (HttpRest.ResponseRaw, 'oauth_token', FAccToken) ;
            IcsExtractURLEncodedValue (HttpRest.ResponseRaw, 'oauth_token_secret', FAccTokSecret) ;
        end;
        if (FAccToken = '') or (FAccTokSecret = '') then begin
            SetError(OAuthErrParams, 'Can Not Find OAuth1 Access Token in Response: ' + HttpRest.ResponseRaw);
            exit;
        end;
        Result := True;
        FExpireDT := Now + 710;  // 2 years
        FRefreshDT := 0;
        LogEvent('Got New Access Token: ' + FAccToken + ', No Expiry, No Refresh');
         if Assigned(FOnOAuthNewToken) then
             FOnOAuthNewToken(Self);
    end
    else begin
        HttpRest.RestParams.Clear;
        HttpRest.RestParams.PContent := PContUrlencoded;
     { note don't URL encode dynamic OAuth stuff }
        HttpRest.RestParams.AddItem('grant_type', 'authorization_code');
        HttpRest.RestParams.AddItem('code', FAuthCode, true);
        HttpRest.RestParams.AddItem('redirect_uri', FRedirectUrl);
        HttpRest.RestParams.AddItem('client_id', FClientId, True);
        HttpRest.RestParams.AddItem('client_secret', FClientSecret, true);
        if (NOT (OAopAuthNoScope in FOAOptions)) and (FScope <> '') then
            HttpRest.RestParams.AddItem('scope', FScope);
        Result := GetToken;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TRestOAuth.GrantRefresh: boolean;
begin
    Result := false;
    if (FRefreshToken = '') then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Missing Refresh Token');
        Exit;
    end;
    if (FClientId = '') or (FClientSecret = '') then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Need Client ID and Secret');
        Exit;
    end;
    HttpRest.RestParams.Clear;
    HttpRest.RestParams.PContent := PContUrlencoded;
     { note don't URL encode dynamic OAuth stuff }
    HttpRest.RestParams.AddItem('grant_type', 'refresh_token');
    HttpRest.RestParams.AddItem('refresh_token', FRefreshToken, true);
    HttpRest.RestParams.AddItem('redirect_uri', FRedirectUrl);
    HttpRest.RestParams.AddItem('client_id', FClientId, True);
    HttpRest.RestParams.AddItem('client_secret', FClientSecret, true);
    Result := GetToken;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TRestOAuth.GrantPasswordToken(const User, Pass: String): boolean;
begin
    Result := false;
    if (User = '') or (Pass = '') then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Missing Username or Password');
        Exit;
    end;
    if (FClientId = '') or (FClientSecret = '') then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Need Client ID and Secret');
        Exit;
    end;
    HttpRest.RestParams.Clear;
    HttpRest.RestParams.PContent := PContUrlencoded;
     { note don't URL encode dynamic OAuth stuff }
    HttpRest.RestParams.AddItem('grant_type', 'password');
    HttpRest.RestParams.AddItem('username', User);
    HttpRest.RestParams.AddItem('password', Pass);
    HttpRest.RestParams.AddItem('client_id', FClientId, True);
    HttpRest.RestParams.AddItem('client_secret', FClientSecret, true);
    if (NOT (OAopAuthNoScope in FOAOptions)) and (FScope <> '') then
        HttpRest.RestParams.AddItem('scope', FScope);
    Result := GetToken;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TRestOAuth.GrantAppToken: boolean;
begin
    Result := false;
    if (FClientId = '') or (FClientSecret = '') then begin
        SetError(OAuthErrParams, 'Can Not Start Authorization, Need Client ID and Secret');
        Exit;
    end;
    HttpRest.RestParams.Clear;
    HttpRest.RestParams.PContent := PContUrlencoded;
     { note don't URL encode dynamic OAuth stuff }
    HttpRest.RestParams.AddItem('grant_type', 'client_credentials');
    HttpRest.RestParams.AddItem('client_id', FClientId, True);
    HttpRest.RestParams.AddItem('client_secret', FClientSecret, true);
    if (NOT (OAopAuthNoScope in FOAOptions)) and (FScope <> '') then
        HttpRest.RestParams.AddItem('scope', FScope, False);
    Result := GetToken;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ TDnsQueryHttps V8.61 }
{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
constructor TDnsQueryHttps.Create (Aowner: TComponent);
begin
    inherited Create(AOwner);
    HttpRest := TSslHttpRest.Create(self);
    HttpRest.OnHttpRestProg := DnsRestProg;
    HttpRest.OnRestRequestDone := DnsRestRequestDone;
    FDnsSrvUrl := DnsPublicHttpsTable[0];
    FDebugLevel := DebugNone;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
destructor TDnsQueryHttps.Destroy;
begin
    FreeAndNil(HttpRest);
    inherited Destroy;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TDnsQueryHttps.DnsRestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
begin
    if Assigned(FOnDnsProg) then
        FOnDnsProg(Self, LogOption, Msg) ;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function  TDnsQueryHttps.DOHQueryAll(Host: String): Boolean;
begin
    FMultiReqSeq  := 1;
    FMultiHost := Host;
    FAnsTot := 0;
    Result := DOHQueryAny(FMultiHost, DnsAllReqTable[FMultiReqSeq], True);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TDnsQueryHttps.DOHQueryAny(Host: String; QNumber: integer; MultiRequests: Boolean = False): Boolean;
var
    QueryBuf: AnsiString;
    QueryLen, StatCode: Integer;
begin
    Result := False;
    if Pos('https://', FDnsSrvUrl) <> 1 then begin
        DnsRestProg(Self, loProtSpecErr, 'Must Specify DNS over HTTPS Server URL');
        Exit;
    end;
    if NOT MultiRequests then FAnsTot := 0;  { reset result records }
    HttpRest.RestParams.Clear;
    HttpRest.DebugLevel := FDebugLevel;
    HttpRest.Accept := MimeDnsMess;
    HttpRest.ContentTypePost := MimeDnsMess;
    HttpRest.NoCache := True;

// build binary wire format request per RFC8484, same as UDP requests RFC1035,
// but ID always 0, so we build and parse requests with TDnsQuery component
    SetLength(QueryBuf, 512);
    BuildRequestHeader(PDnsRequestHeader(@QueryBuf[1]),0,
                                           DnsOpCodeQuery, TRUE, 1, 0, 0, 0);
    QueryLen := BuildQuestionSection(@QueryBuf[SizeOf(TDnsRequestHeader) + 1],
                                              IcsTrim(Host), QNumber, DnsClassIN);  { V8.64 }
    QueryLen := QueryLen + SizeOf(TDnsRequestHeader);
    SetLength(QueryBuf, QueryLen);
    StatCode := HttpRest.RestRequest(httpPOST, FDnsSrvUrl, True, String(QueryBuf));  // async request
    Result := (StatCode = 0);  // raises exception on failure
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TDnsQueryHttps.DnsRestRequestDone(Sender: TObject; RqType: THttpRequest; ErrCode: Word);
var
    RespBuf: AnsiString;
begin
    if ErrCode <> 0 then begin
        DnsRestProg(Self, loProtSpecErr, 'Request failed, error #' + IntToStr(ErrCode) +
              '. Status = ' + IntToStr(HttpRest.StatusCode) + ' - ' + HttpRest.ReasonPhrase);
        TriggerRequestDone(ErrCode);
        Exit;
    end;
    if (HttpRest.StatusCode = 200) and (HttpRest.ContentType = MimeDnsMess) then begin
        RespBuf := HttpRest.ResponseOctet;
        if DecodeWireResp(@RespBuf[1], HttpRest.ContentLength) then begin

           // if simulating ALL request make next request in sequence
            if FMultiReqSeq > 0 then begin
                FMultiReqSeq := FMultiReqSeq + 1;
                if FMultiReqSeq <= DnsAllReqTot then begin
                    DOHQueryAny(FMultiHost, DnsAllReqTable[FMultiReqSeq], True);
                    Exit;
                end;
                FMultiReqSeq := 0;
            end;
            TriggerRequestDone(0);  // all done
        end
        else
            TriggerRequestDone(99);
    end
    else
       TriggerRequestDone(HttpRest.StatusCode);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ TIcsSms V8.61 }
{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
constructor TIcsSms.Create (Aowner: TComponent);
begin
    inherited Create(AOwner);
    HttpRest := TSslHttpRest.Create(self);
    HttpRest.OnHttpRestProg := SmsRestProg;
    HttpRest.OnRestRequestDone := SmsRestRequestDone;
    FSmsProvider := SmsProvKapow;
    FDebugLevel := DebugNone;
    FSendDT := Now;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
destructor TIcsSms.Destroy;
begin
    FreeAndNil(HttpRest);
    inherited Destroy;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsSms.SetAccountJson(Value: String);   { V8.65 }
begin
    if FAccountJson <> Value then begin
        FAccountJson := Value;
        FAccountJwt := '';       // force new JWT
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsSms.SmsRestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
begin
    if Assigned(FOnSmsProg) then
        FOnSmsProg(Self, LogOption, Msg) ;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsSms.MakeRequest(HttpRequest: THttpRequest; const RestURL: String;
                      AsyncReq: Boolean = False; const RawParams: String = ''): Boolean;
var
    StatCode: Integer;
    LoginJson: ISuperObject;
    WideAcc: WideString;
//    JwtPayload, NewAccoutJwt: String;
//    UnixTime: Int64;
begin
    Result := False;
    FLastError := '';
    FLastResp := '';
    FCredits := '';
    FSentID := '';
    FDelivery := '';
    if FSmsProvider = SmsProvKapow then begin
        if (FAccountName = '') or (FAccountPw = '') then begin
            FLastError := 'Must Specify Kapow Account Login';
            Exit;
        end;
        HttpRest.RestParams.AddItem('username', FAccountName);
        HttpRest.RestParams.AddItem('password', FAccountPW);
        HttpRest.RestParams.PContent := PContUrlencoded;
        HttpRest.SslCliSecurity := sslCliSecBack;  // only supports TLS1 !!!
        HttpRest.DebugLevel := FDebugLevel;
        StatCode := HttpRest.RestRequest(httpPOST, RestURL, AsyncReq, RawParams);
        if AsyncReq then
            Result := (StatCode = 0)
        else
            Result := (StatCode = 200);  // raises exception on failure
    end
    else if FSmsProvider = SmsProvSmsWorks then begin
        WideAcc := FAccountJson;
        LoginJson := TSuperObject.ParseString(PWideChar(WideAcc), True);
    (*  this block of Json come from The SMS Works account API, convert it into JWT
     {
      "customerid": "8545-xxxx-4e16-45bf-xxxx-506561072b83",
      "key": "a87166be-xxxx-4cf3-xxxx-d6cdbd85fcfd",
      "secret": "a29b39ax7x8x1xaxcx9x2xaxbx8x9x7x2xcx4xfxdx2x4xx8078b5f2f49d5f253"
    }  *)
        if NOT Assigned(LoginJson) then  begin
            FLastError := 'The SMS Works Needs Valid Login Json from Account';   { V8.63 removed space, added The }
            Exit;
        end;

     { see if have Json Web Token, otherwise get it using login Json }
        if FAccountJwt = '' then begin
            HttpRest.ServerAuth := httpAuthNone;
            HttpRest.ContentTypePost := 'application/json;charset=UTF-8';
            HttpRest.SslCliSecurity := sslCliSecHigh;
            HttpRest.DebugLevel := FDebugLevel;
            StatCode := HttpRest.RestRequest(httpPOST, 'https://api.thesmsworks.co.uk/v1/auth/token', False, FAccountJson);
            if (StatCode <> 200) then begin
                FLastResp := HttpRest.ResponseRaw;
                FLastError := HttpRest.ResponseJson.S['message'];
                Exit;
            end;
            FAccountJwt := HttpRest.ResponseJson.S['token'];
            if Pos ('JWT ', FAccountJwt) = 1 then
                FAccountJwt := Copy(FAccountJwt, 5, 99999)
            else begin
                FLastError := 'Invalid JWT Token from The SMS Works';    { V8.63 added The }
                Exit;
            end;
        end;

     { we should be able to build JWT but SMS Works rejects our attempt with bad signature }
 (*   //    if FAccountJwt = '' then begin
            JwtPayload := IcsHexToBin(LoginJson.S['secret']);
            if  Length (JwtPayload) <> 32 then  begin
                FLastError := 'Invalid secret length';
                Exit;
            end;
            UnixTime := IcsGetUnixTime;
            JwtPayload := '{"key":"' + LoginJson.S['key'] + '","secret":"' +
                        LoginJson.S['secret'] + '","iat":' + IntToStr(UnixTime) +
                               '"exp":' + IntToStr(UnixTime+(SecsPerDay*3000)) +'}';  // issued at, expiree at, Unix time
            NewAccoutJwt := IcsJoseJWSComp(jsigHmac256, JwtPayload,
                         IcsHexToBin(LoginJson.S['secret']), Nil, 'JWT', '', '', '', '');
            if NewAccoutJwt <> FAccountJwt then
                HttpRest.LogEvent('Mismatch JWT: API=' + FAccountJwt + ', JWSComp=' + NewAccoutJwt + ' - ' +  JwtPayload);
    //    end;     *)

        HttpRest.AuthBearerToken := FAccountJwt;
        HttpRest.ServerAuth := httpAuthJWT;
        HttpRest.Accept := 'application/json;charset=UTF-8';
        HttpRest.RestParams.PContent := PContJson;
        HttpRest.SslCliSecurity := sslCliSecHigh;
        HttpRest.DebugLevel := FDebugLevel;
        StatCode := HttpRest.RestRequest(HttpRequest, RestURL, AsyncReq, RawParams);
        if AsyncReq then
            Result := (StatCode = 0)
        else
            Result := (StatCode = 200) or (StatCode = 201);  // raises exception on failure V8.63 or 201
    end
    else begin
        FLastError := 'Unknown Provider';
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsSms.SendSms(const MobileNums, SmsMsg: String; AsyncReq: Boolean = True): Boolean;
var
    Msg, NumArray, Path: String;
    NumList: TStringList;
    I: Integer;
begin
    Result := False;
    FLastError := '';
    NumList := TStringList.Create;
    try
        if (Length(SmsMsg) = 0)  then begin
           FLastError := 'Must Specify SMS Message';
            Exit;
        end;
        Msg := Trim(SmsMsg); // remove training CRLF
        if (Length(MobileNums) < 6) then begin
            FLastError := 'Must Specify Longer Mobile Telephone Number';
            Exit;
        end;
        NumList.CommaText := MobileNums;
        if NumList.Count = 0 then Exit; // can not be blank
    // remove blank or suppressed lines
        for I := 0 to NumList.Count - 1 do begin
            if (Length(NumList[I]) = 0) or
                (NumList[I][1] = '*') then
                    NumList.Delete(I);
            if I >= NumList.Count then break;
        end;
        if NumList.Count = 0 then Exit; // can not be blank
        for I := 0 to NumList.Count - 1 do begin
            NumList[I] := StringReplace(NumList[I], IcsSpace, '', [rfReplaceAll]);
            if (Pos ('00', NumList[I]) = 1) then begin
                FLastError := 'Internaional Access Code Not Needed - ' + NumList[I];
                Exit;
            end;
            if Length(NumList[I]) < 6 then begin
                FLastError := 'Must Specify Longer Mobile Telephone Number - ' + NumList[I];
                Exit;
            end;
        end;
        if FSmsProvider = SmsProvKapow then begin
            HttpRest.ServerAuth := httpAuthNone;
            Msg := StringReplace(Msg, IcsCRLF, '\r', [rfReplaceAll]);
            HttpRest.RestParams.Clear;
            HttpRest.RestParams.AddItem('mobile', NumList[0]);     // only one at moment!!
            if FMsgSender <> '' then
                HttpRest.RestParams.AddItem('from_id', FMsgSender, False);
            HttpRest.RestParams.AddItem('returnid', 'TRUE');  // non-standard
            HttpRest.RestParams.AddItem('sms', Msg, False);
            FSmsOperation := SmsOpSend;
            Result := MakeRequest(httpPOST, 'https://secure.kapow.co.uk/scripts/sendsms.php', AsyncReq);
        end
        else if FSmsProvider = SmsProvSmsWorks then begin
            HttpRest.RestParams.Clear;
            if NumList.Count = 1 then begin
                HttpRest.RestParams.AddItem('destination', NumList[0]);
                Path := 'message/send';
            end
            else begin
                NumArray := '["';
                for I := 0 to NumList.Count - 1 do
                    NumArray := NumArray + NumList[I] + '","';
                SetLength(NumArray, Length(NumArray)-2);
                NumArray := NumArray + ']';
                Path := 'batch/send';
                HttpRest.RestParams.AddItem('destinations', NumArray, True);
            end;
            if FMsgSender <> '' then
                HttpRest.RestParams.AddItem('sender', FMsgSender);
            HttpRest.RestParams.AddItem('content', Msg);
            HttpRest.RestParams.AddItem('tag', 'ICS');
            HttpRest.RestParams.AddItemDT('schedule', FSendDT);  // ISO time in UTC with time zone
            FSmsOperation := SmsOpSend;
            Result := MakeRequest(httpPOST, 'https://api.thesmsworks.co.uk/v1/' + Path, AsyncReq);
        end
        else begin
            FLastError := 'Unknown Provider';
        end;
    finally
        NumList.Free;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsSms.CheckSMS(ID: String; AsyncReq: Boolean = True; Batch: Boolean = False): Boolean;
begin
    Result := False;
    FLastError := '';
    if (ID = '') then begin
        FLastError := 'Must Specify Message ID';
        Exit;
    end;
    if FSmsProvider = SmsProvKapow then begin
        HttpRest.RestParams.Clear;
        HttpRest.RestParams.AddItem('returnid', ID);
        FSmsOperation := SmsOpCheck;
        Result := MakeRequest(httpPOST, 'https://secure.kapow.co.uk/scripts/chk_status.php', AsyncReq);
    end
    else if FSmsProvider = SmsProvSmsWorks then begin
        HttpRest.RestParams.Clear;
        FSmsOperation := SmsOpCheck;
        if Batch then
            Result := MakeRequest(httpGET, 'https://api.thesmsworks.co.uk/v1/batch/' + ID, AsyncReq)
        else
            Result := MakeRequest(httpGET, 'https://api.thesmsworks.co.uk/v1/messages/' + ID, AsyncReq);
    end
    else begin
        FLastError := 'Unknown Provider';
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsSms.CheckCredit( AsyncReq: Boolean = True): Boolean;
begin
    Result := False;
    FLastError := '';
    if FSmsProvider = SmsProvKapow then begin
        HttpRest.RestParams.Clear;
        FSmsOperation := SmsOpCredit;
        Result := MakeRequest(httpPOST, 'https://secure.kapow.co.uk/scripts/chk_credit.php', AsyncReq);
    end
    else if FSmsProvider = SmsProvSmsWorks then begin
        HttpRest.RestParams.Clear;
        FSmsOperation := SmsOpCredit;
        Result := MakeRequest(httpGET, 'https://api.thesmsworks.co.uk/v1/credits/balance', AsyncReq);
    end
    else begin
        FLastError := 'Unknown Provider';
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsSms.SmsRestRequestDone(Sender: TObject; RqType: THttpRequest; ErrCode: Word);
var
    S: String;
    J: Integer;
begin
    if ErrCode <> 0 then begin
        if ErrCode = 401 then
            FLastError := 'Failed: Account Not Authorised'   { V8.65 }
        else
            FLastError := 'Failed, error #' + IntToStr(ErrCode) +
              '. Status ' + IntToStr(HttpRest.StatusCode) + ' - ' + HttpRest.ReasonPhrase;
        if Assigned(FOnSmsDone) then FOnSmsDone(Self);
        Exit;
    end;
    if FSmsProvider = SmsProvKapow then begin

      // Kapow returns simple text, no formatting or tags or line end
        if (HttpRest.StatusCode = 200) then begin
            FLastResp := HttpRest.ResponseRaw;
            if FLastResp = 'ERROR' then
                FLastError := 'Failed: Kapow Reports an Error'
            else if FLastResp = 'USERPASS' then
                FLastError := 'Failed: Kapow Reports Invalid Account Details'
            else if FLastResp = 'NOCREDIT' then
                FLastError := 'Failed: Kapow Reports No Account Credit'
            else begin
                if FSmsOperation = SmsOpCredit then begin
                    FCredits := FLastResp;
                    FLastError := '';
                end
                else if FSmsOperation = SmsOpSend then begin
                    if  Pos ('OK', FLastResp) = 1 then begin // OK 148 11472734895956042
                        FLastError := '';
                        S := Trim (Copy (FLastResp, 4, 999));
                        J := Pos (IcsSpace, S);
                        if J > 0 then begin
                            FCredits := Copy (S, 1, Pred (J));
                            FSentID := Copy (S, Succ (J), 999);
                        end ;
                    end;
                end
                else if FSmsOperation = SmsOpCheck then begin
                    if FLastResp = 'D' then begin
                        FDelivery := 'SMS Delivered OK';
                        FLastError := '';
                    end
                    else if FLastResp = 'N' then
                        FDelivery := 'Message Awaiting Delivery'
                    else if FLastResp = 'S' then
                        FDelivery := 'Sent to SMSC'
                    else if FLastResp = 'B' then
                        FDelivery := 'Message Buffered Awaiting Delivery'
                    else if FLastResp = 'R' then
                        FDelivery := 'Retrying Message'
                    else if FLastResp = 'X' then
                        FDelivery := 'Message Delivery Failed'
                    else
                        FDelivery := 'Unknown Delivery: ' + FLastResp;
                end
                else
                    FLastError := 'Failed: Unexpected Kapow Response - ' + FLastResp;
            end
        end
        else
            FLastError := 'Failed: Status ' + IntToStr(HttpRest.StatusCode) + ' - ' +
                                                              HttpRest.ReasonPhrase;
    end
    else if FSmsProvider = SmsProvSmsWorks then begin

      // The SMS Works returns Json
        if (HttpRest.StatusCode = 201) then begin
            FLastResp := HttpRest.ResponseRaw;
            if FSmsOperation = SmsOpSend then begin
                FSentID := HttpRest.ResponseJson.S['messageid'];
                FCredits := HttpRest.ResponseJson.S['credits'];
                FDelivery := HttpRest.ResponseJson.S['status'];
                if FSentID = '' then
                    FSentID := HttpRest.ResponseJson.S['batchid'];  // should really keep separately !!
                FLastError := '';
            end;
        end
        else if (HttpRest.StatusCode = 200) then begin
          // ignore response getting token, no event
            if (Pos ('auth/token', HttpRest.URL) > 0) then Exit;
            if FSmsOperation = SmsOpCredit then begin
                FCredits := HttpRest.ResponseJson.S['credits'];
                FLastError := '';
            end
            else if FSmsOperation = SmsOpCheck then begin
                FCredits := HttpRest.ResponseJson.S['credits'];
                FDelivery := HttpRest.ResponseJson.S['status'];
                FLastError := '';
             // pending check batch response, array for each message
            end;
        end
        else if (HttpRest.StatusCode >= 400) then begin
            FLastError := 'Failed: SMS Works Account Not Authorised';   { V8.65 }
            FLastResp := HttpRest.ResponseRaw;
            if (Length(FLastResp) > 10) and Assigned(HttpRest.ResponseJson) then
                FLastError := HttpRest.ResponseJson.S['message'];
        end
        else
            FLastError := 'Failed: Status ' + IntToStr(HttpRest.StatusCode) + ' - ' +
                                                              HttpRest.ReasonPhrase;
        if (FDelivery = 'DELIVERED') or  (FDelivery = 'SENT') then begin   { V8.63 same responses as Kapow }
            FDelivery := 'SMS Delivered OK';
            FLastError := '';
        end
        else if (FDelivery = 'REJECTED') or (FDelivery = 'UNDELIVERABLE') then
            FDelivery := 'Message Delivery Failed';

     end;
    if Assigned(FOnSmsDone) then FOnSmsDone(Self);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ V8.65 TIcsTwitter to send and receive tweets }
{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
constructor TIcsTwitter.Create (Aowner: TComponent);
begin
    inherited Create(AOwner);
    HttpRest := TSslHttpRest.Create(self);
    HttpRest.OnHttpRestProg := TwitRestProg;
    HttpRest.RestParams.PContent := PContUrlencoded;
    HttpRest.RestParams.RfcStrict := True;
    FDebugLevel := DebugNone;
    FRestOAuth := TRestOAuth.Create(self);
    FRestOAuth.OnOAuthProg := TwitRestProg;
    FRestOAuth.OnOAuthNewToken := TwitNewToken;
    FRestOAuth.ProtoType := OAuthv1A;
    FRestOAuth.LoadAuthUri(OAuthUriTwitterOA1);
    FBaseURL := 'https://api.twitter.com/1.1/';
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
destructor TIcsTwitter.Destroy;
begin
    FreeAndNil(FRestOAuth);
    FreeAndNil(HttpRest);
    inherited Destroy;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsTwitter.TwitRestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
begin
    if Assigned(FOnTwitProg) then
        FOnTwitProg(Self, LogOption, Msg) ;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsTwitter.TwitNewToken(Sender: TObject);
begin
    FAccToken := FRestOAuth.AccToken;
    FAccTokSecret := FRestOAuth.AccTokSecret;
    IcsExtractURLEncodedValue (FRestOAuth.HttpRest.ResponseRaw, 'user_id', FAccUserId) ;
    IcsExtractURLEncodedValue (FRestOAuth.HttpRest.ResponseRaw, 'screen_name', FAccScreenName) ;
    if Assigned(FOnTwitNewToken) then
        FOnTwitNewToken(Self) ;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsTwitter.StartAuthorization: boolean;
begin
    Result := False;
    FLastError := '';
    if (FConApiKey = '') or (FConApiSecret= '') then begin
        FLastError := 'Can Not Login, Need Consumer API Key and Secret';
        Exit;
    end;
    FRestOAuth.DebugLevel := FDebugLevel;
    FRestOAuth.FClientId := FConApiKey;
    FRestOAuth.FClientSecret := FConApiSecret;
    if FForceLogin then
       FRestOAuth.OAOptions := [OAopAuthPrompt]
    else
        FRestOAuth.OAOptions := [];
//    FRestOAuth.FAppUrl := 'https://api.twitter.com/oauth/authorize';   // always shows window
    FRestOAuth.AppUrl := 'https://api.twitter.com/oauth/authenticate';   // logged in user skips window
    Result := FRestOAuth.StartAuthorization;
    if Result then begin
       // need to wait for browser callback which triggers TwitNewToken event
    end
    else
        FLastError := FRestOAuth.LastError;
    FResponseRaw := FRestOAuth.HttpRest.ResponseRaw;
    FResponseJson := FRestOAuth.HttpRest.ResponseJson;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsTwitter.CommonSettings: boolean;
begin
    Result := False;
    FLastError := '';
    if (FConApiKey = '') or (FConApiSecret = '') then begin
        FLastError := 'Can Not Send Tweet, Need Consumer API Key and Secret';
        Exit;
    end;
    if (FAccToken = '') or (FAccTokSecret = '') then begin
        FLastError := 'Can Not Send Tweet, Must Login First to get Access Token and Secret';
        Exit;
    end;
    HttpRest.DebugLevel := FDebugLevel;
    FRestOAuth.DebugLevel := FDebugLevel;
    FRestOAuth.FClientId := FConApiKey;
    FRestOAuth.FClientSecret := FConApiSecret;
    FRestOAuth.AccToken := FAccToken;
    FRestOAuth.AccTokSecret := FAccTokSecret;
    Result := True;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Notes for adding new Twitter APIs
Each Twitter GET or POST request must be OAuth1A signed, with the hash signature
generated from a string that includes several fixed OAuth1A parameters and the
full URL of the request including query parameters, and the POST content.
The OAuth1A parameters and hash signature are then added as a header:
Authorization: OAuth oauth_consumer_key="xx", oauth_nonce="xx", oauth_signature="xx" etc

In the functions below, OAuthParams are built twice, once for the signbase
which includes request type, URL and request parameters, the has signature is
built by GetOAuthSignature, the Authorization bearer is built by adding
the new signature and removing the request paramaters, finally the request
parameters are added to RestParams and the URL to make the real REST request.

There is surely a better way to do this that avoids duplicating a lot of code
below, but it works...
}
{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsTwitter.SendTweet(const Msg: String): boolean;
var
    TwitURL, Signature, UrlParam, Msg2: String;
    ErrJson, UserJson: ISuperObject;
    StatCode: Integer;
begin
    Result := False;
    if NOT CommonSettings then Exit;
    TwitURL := FBaseURL + 'statuses/update.json';
    UrlParam := '?include_entities=false';   // change below as well!
    Msg2 := Trim(Msg);

// build base string, used for hashed signature
// must include POST content and URL paramaters, sorted
    FRestOAuth.OAuthParams.Clear;
    FRestOAuth.OAuthParams.AddItem('status', Msg2);
    FRestOAuth.OAuthParams.AddItem('include_entities', False);
    Signature := FRestOAuth.GetOAuthSignature('POST', TwitURL, False);   // adds OAuth1 parameters

// adjust base string for Authorization: OAuth header, add signature, remove parameters
    FRestOAuth.OAuthParams.RemoveItem('status');
    FRestOAuth.OAuthParams.RemoveItem('include_entities');
    FRestOAuth.OAuthParams.AddItem('oauth_signature', Signature);
    HttpRest.ServerAuth := httpAuthOAuth;
    FRestOAuth.OAuthParams.PContent := PContCommaList;  // change paramter format
    HttpRest.AuthBearerToken := String(FRestOAuth.OAuthParams.GetParameters(True)); // bearer is quoted encoded values, comma separated
    TwitRestProg(Self, loProtSpecInfo, 'Authorization: OAuth ' + HttpRest.AuthBearerToken);

 // now build POST content and URL with parameters
    HttpRest.RestParams.Clear;
    HttpRest.RestParams.AddItem('status', Msg2);
    TwitURL := TwitURL + UrlParam;
    StatCode := HttpRest.RestRequest(httpPOST, TwitURL, False, '');
    if FDebugLevel < DebugBody then  // not already logging it
        TwitRestProg(Self, loProtSpecInfo, String(HttpRest.ResponseRaw));
    if (StatCode <> 200) then begin
        FLastError := HttpRest.ResponseRaw;
        if FLastError = '' then
            FLastError := HttpRest.LastResponse
        else begin
            if Assigned(HttpRest.ResponseJson) then begin
                ErrJson := HttpRest.ResponseJson.O['errors'];
                if Assigned(ErrJson) and (ErrJson.AsArray.Length > 0) then
                    FLastError := ErrJson.AsArray.O[0].S['message'];
            end;
        end;
    end
    else begin
        Result := True;
        FLastTweetId := HttpRest.ResponseJson.S['id'];
        UserJson := HttpRest.ResponseJson.O['user'];
        FAccScreenName := UserJson.S['screen_name'];
        FAccUserId := UserJson.S['id'];
    end;
    HttpRest.Close;
    FResponseRaw := HttpRest.ResponseRaw;
    FResponseJson := HttpRest.ResponseJson;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsTwitter.GetAccSett: boolean;
var
    TwitURL, Signature: String;
    StatCode: Integer;
    ErrJson: ISuperObject;
begin
    Result := False;
    if NOT CommonSettings then Exit;
    TwitURL := FBaseURL + 'account/settings.json';
// build base string, used for hashed signature
// must include POST content and URL paramaters, sorted
    FRestOAuth.OAuthParams.Clear;
    Signature := FRestOAuth.GetOAuthSignature('GET', TwitURL, False);   // adds OAuth1 parameters

// adjust base string for Authorization: OAuth header, add signature
    FRestOAuth.OAuthParams.AddItem('oauth_signature', Signature);
    HttpRest.ServerAuth := httpAuthOAuth;
    FRestOAuth.OAuthParams.PContent := PContCommaList;  // change paramter format
    HttpRest.AuthBearerToken := String(FRestOAuth.OAuthParams.GetParameters(True)); // bearer is quoted encoded values, comma separated
    TwitRestProg(Self, loProtSpecInfo, 'Authorization: OAuth ' + HttpRest.AuthBearerToken);

 // now build POST content and URL
    HttpRest.RestParams.Clear;
    StatCode := HttpRest.RestRequest(httpGET, TwitURL, False, '');
    if FDebugLevel < DebugBody then  // not already logging it
        TwitRestProg(Self, loProtSpecInfo, String(HttpRest.ResponseRaw));
    if (StatCode <> 200) then begin
        FLastError := HttpRest.ResponseRaw;
        if FLastError = '' then
            FLastError := HttpRest.LastResponse
        else begin
            if Assigned(HttpRest.ResponseJson) then begin
                ErrJson := HttpRest.ResponseJson.O['errors'];
                if Assigned(ErrJson) and (ErrJson.AsArray.Length > 0) then
                    FLastError := ErrJson.AsArray.O[0].S['message'];
            end;
        end;
    end
    else begin
        Result := True;
    end;
    FResponseRaw := HttpRest.ResponseRaw;
    FResponseJson := HttpRest.ResponseJson;
 end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsTwitter.SearchTweets(const Query: String): boolean;
var
    TwitURL, Signature: String;
    StatCode: Integer;
    ErrJson: ISuperObject;
begin
    Result := False;
    if NOT CommonSettings then Exit;
    TwitURL := FBaseURL + 'search/tweets.json';

// build base string, used for hashed signature
// must include POST content and URL paramaters, sorted
    FRestOAuth.OAuthParams.Clear;
    FRestOAuth.OAuthParams.AddItem('q', Query);
    FRestOAuth.OAuthParams.AddItem('count', 50);
    Signature := FRestOAuth.GetOAuthSignature('GET', TwitURL, False);   // adds OAuth1 parameters

// adjust base string for Authorization: OAuth header, add signature, remove parameters
    FRestOAuth.OAuthParams.RemoveItem('q');
    FRestOAuth.OAuthParams.RemoveItem('count');
    FRestOAuth.OAuthParams.AddItem('oauth_signature', Signature);
    HttpRest.ServerAuth := httpAuthOAuth;
    FRestOAuth.OAuthParams.PContent := PContCommaList;  // change paramter format
    HttpRest.AuthBearerToken := String(FRestOAuth.OAuthParams.GetParameters(True)); // bearer is quoted encoded values, comma separated
    TwitRestProg(Self, loProtSpecInfo, 'Authorization: OAuth ' + HttpRest.AuthBearerToken);

 // now build POST content and URL with parameters
    HttpRest.RestParams.Clear;
    HttpRest.RestParams.AddItem('q', Query);
    HttpRest.RestParams.AddItem('count', 50);
    StatCode := HttpRest.RestRequest(httpGET, TwitURL, False, '');
    if FDebugLevel < DebugBody then  // not already logging it
        TwitRestProg(Self, loProtSpecInfo, String(HttpRest.ResponseRaw));
    if (StatCode <> 200) then begin
        FLastError := HttpRest.ResponseRaw;
        if FLastError = '' then
            FLastError := HttpRest.LastResponse
        else begin
            if Assigned(HttpRest.ResponseJson) then begin
                ErrJson := HttpRest.ResponseJson.O['errors'];
                if Assigned(ErrJson) and (ErrJson.AsArray.Length > 0) then
                    FLastError := ErrJson.AsArray.O[0].S['message'];
            end;
        end;
    end
    else begin
        Result := True;
    end;
    FResponseRaw := HttpRest.ResponseRaw;
    FResponseJson := HttpRest.ResponseJson;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}

{ NOTE: ListTweets and SearchTweets seem to give an "Could not authenticate you."
  error if called immediately after SendTweet, no idea why, the signature seems OK.  }

{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsTwitter.ListTweets(const IdList: String): boolean;
var
    TwitURL, Signature: String;
    ErrJson: ISuperObject;
    StatCode: Integer;
begin
    Result := False;
    if NOT CommonSettings then Exit;
    TwitURL := FBaseURL + 'statuses/lookup.json';

// build base string, used for hashed signature
// must include POST content and URL paramaters, sorted
    FRestOAuth.OAuthParams.Clear;
    FRestOAuth.OAuthParams.AddItem('id', IdList);
    Signature := FRestOAuth.GetOAuthSignature('GET', TwitURL, False);   // adds OAuth1 parameters

// adjust base string for Authorization: OAuth header, add signature, remove parameters
    FRestOAuth.OAuthParams.RemoveItem('id');
    FRestOAuth.OAuthParams.AddItem('oauth_signature', Signature);
    HttpRest.ServerAuth := httpAuthOAuth;
    FRestOAuth.OAuthParams.PContent := PContCommaList;  // change paramter format
    HttpRest.AuthBearerToken := String(FRestOAuth.OAuthParams.GetParameters(True)); // bearer is quoted encoded values, comma separated
    TwitRestProg(Self, loProtSpecErr, 'Authorization: OAuth ' + HttpRest.AuthBearerToken);

 // now build POST content and URL with parameters
    HttpRest.RestParams.Clear;
    HttpRest.RestParams.AddItem('id', IdList);
    StatCode := HttpRest.RestRequest(httpGET, TwitURL, False, '');
    if FDebugLevel < DebugBody then  // not already logging it
        TwitRestProg(Self, loProtSpecInfo, String(HttpRest.ResponseRaw));
    if (StatCode <> 200) then begin
        FLastError := HttpRest.ResponseRaw;
        if FLastError = '' then
            FLastError := HttpRest.LastResponse
         else begin
            if Assigned(HttpRest.ResponseJson) then begin
                ErrJson := HttpRest.ResponseJson.O['errors'];
                if Assigned(ErrJson) and (ErrJson.AsArray.Length > 0) then
                    FLastError := ErrJson.AsArray.O[0].S['message'];
            end;
         end;
    end
    else begin
        Result := True;
    end;
    FResponseRaw := HttpRest.ResponseRaw;
    FResponseJson := HttpRest.ResponseJson;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
constructor TIcsRestEmail.Create (Aowner: TComponent);
begin
    inherited Create(AOwner);
    HttpRest := TSslHttpRest.Create(self);
    HttpRest.OnHttpRestProg := EmailRestProg;
    HttpRest.RestParams.PContent := PContUrlencoded;
    HttpRest.RestParams.RfcStrict := True;
    FDebugLevel := DebugNone;
    FRestOAuth := TRestOAuth.Create(self);
    FRestOAuth.OnOAuthProg := EmailRestProg;
    FRestOAuth.OnOAuthNewToken := EmailNewToken;
    FRestOAuth.ProtoType := OAuthv2;
    FOAAuthType := FRestOAuth.AuthType;   { V8.66 }
    FRestEmailType := RestEmailGoogle;
    FLoginTimeout := 120;                 { V8.66 was 30, but need to get past several web pages }
    FWaitSecs := 0;
    FHdrFieldList := 'to,from,subject,date';
    FCancelFlag := False;
end;

{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
destructor TIcsRestEmail.Destroy;
begin
    FreeAndNil(FRestOAuth);
    FreeAndNil(HttpRest);
    inherited Destroy;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsRestEmail.Clear;
begin
    FNewAccEmail := '';
    FNewAccName := '';
    FAccToken := '';
    FAccExpireDT := 0;
    FLastError := '';
    FLastErrCode := 0;
    FNewAccScope := '';
    FTokenType := '';
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsRestEmail.EmailRestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
begin
    if Assigned(FOnEmailProg) then
        FOnEmailProg(Self, LogOption, Msg) ;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsRestEmail.EmailNewToken(Sender: TObject);
begin
    FRestOAuth.StopSrv(False);  { V8.65 close server but not current client }
    FNewAccEmail := '';
    FNewAccName := '';
    FAccToken := FRestOAuth.AccToken;
    FAccExpireDT := FRestOAuth.ExpireDT;
    if FRestOAuth.RefreshToken <> '' then  { google only supplies refresh once }
        FRefrToken := FRestOAuth.RefreshToken;
    IcsExtractURLEncodedValue (FRestOAuth.HttpRest.ResponseRaw, 'scope', FNewAccScope) ;
    IcsExtractURLEncodedValue (FRestOAuth.HttpRest.ResponseRaw, 'token_type', FTokenType) ;

// get profile for email address to find out what account we logged into
    GetProfile;
    if FTokenType <> '' then
        HttpRest.LogEvent('Token Type: ' + FTokenType + ', Scope: ' + FNewAccScope);

 // tell user we got something
    if Assigned(FOnEmailNewToken) then
        FOnEmailNewToken(Self) ;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsRestEmail.CommonSettings: boolean;
begin
    Result := False;
    FLastError := '';
    if (FCliID = '') or (FCliSecret = '') then begin
        FLastError := 'Can Not Send Email, Need Application Client ID and Secret';
        Exit;
    end;
    HttpRest.ServerAuth := httpAuthBearer;
    HttpRest.AuthBearerToken := FAccToken;
    HttpRest.DebugLevel := FDebugLevel;
    HttpRest.RestParams.PContent := PContUrlencoded;
    HttpRest.RestParams.Clear;
    FRestOAuth.DebugLevel := FDebugLevel;
    FRestOAuth.OAOptions := [OAopAuthAccess];

// set-up common URLs and local web server details for common providers
    if FRestEmailType = RestEmailGoogle then begin
        FRestOAuth.LoadAuthUri(OAuthUriGoogle);
        FBaseURL := 'https://www.googleapis.com/gmail/v1/users/';
        FRestOAuth.OAOptions := FRestOAuth.OAOptions + [OAopAuthGrantedScope];
    end
    else if FRestEmailType = RestEmailMSRest then begin
        FRestOAuth.LoadAuthUri(OAuthUriMSRest);
        FBaseURL := 'https://graph.microsoft.com/v1.0/';
        FRestOAuth.ResponseMode := 'query';
        FRestOAuth.LoginHint := FAccountHint;
        FRestOAuth.OAOptions := FRestOAuth.OAOptions + [OAopAuthRespMode, OAopAuthLoginHint];
    end
    else if FRestEmailType = RestEmailMSSmtp then begin
        FRestOAuth.LoadAuthUri(OAuthUriMSSmtp);
        FBaseURL := 'https://graph.microsoft.com/v1.0/';
        FRestOAuth.ResponseMode := 'query';
        FRestOAuth.LoginHint := FAccountHint;
        FRestOAuth.OAOptions := FRestOAuth.OAOptions + [OAopAuthRespMode, OAopAuthLoginHint];
    end
    else begin
        FLastError := 'Unsupported Email Provider';
        Exit;
    end;

// load information needed to access OAuth2 authentication, may expires after a year or more
    FRestOAuth.ClientId := FCliID;
    FRestOAuth.ClientSecret := FCliSecret;
    FRestOAuth.RefreshOffline := True;     // need for offline to get refresh token

// dynamic stuff returned by OAuth2, if saved avoids getting it again
//    if FAccToken <> '' then begin           { V8.66 always set to avoid old data being found }
        FRestOAuth.AccToken := FAccToken;
        FRestOAuth.ExpireDT := FAccExpireDT;   // for access token, usually less than one day
//    end;
 //   if FRefrToken <> '' then
        FRestOAuth.RefreshToken := FRefrToken;    // usually expires after several months
    Result := True;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsRestEmail.SetOAuthErrs;               { V8.66 }
begin
    FLastErrCode := FRestOAuth.LastErrCode;
    FLastError := FRestOAuth.LastError;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsRestEmail.TestRedirect: boolean;
begin
    Result := False;
    if NOT CommonSettings then Exit;
    Result := FRestOAuth.TestRedirect;
    if NOT Result then SetOAuthErrs;              { V8.66 }
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsRestEmail.LaunchConsole: boolean;
begin
    Result := False;
    if NOT CommonSettings then Exit;
    Result := FRestOAuth.LaunchConsole;
    if NOT Result then SetOAuthErrs;              { V8.66 }
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsRestEmail.StartAuthorization: boolean;
begin
    Result := False;
    Clear;
    if NOT CommonSettings then Exit;
    if FForceLogin then begin
        FRestOAuth.LoginPrompt := 'select_account';
        FRestOAuth.OAOptions := FRestOAuth.OAOptions + [OAopAuthPrompt];
    end;
    Result := FRestOAuth.StartAuthorization;
    if NOT Result then SetOAuthErrs;              { V8.66 }
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsRestEmail.UpdateToken: Boolean;
begin
    Result := False;
    if NOT CommonSettings then Exit;
    Result := FRestOAuth.GrantRefresh;
    if NOT Result then SetOAuthErrs;              { V8.66 }
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ this function should be called SMTP and POP3 clients needing an OAuth2
  bearer token, it should return quickly if a refresh token is available
  but if not will need to launch a browser windows for the user to login,
  it will wait LoginTimeout seconds for this to happen before failing,
  or will fail immediately is Interactive is false, for servers.
  V8.66 servers may also set OAAuthType=OAuthTypeMan and an event from
  which to call the browser URL perhaps via email }
function TIcsRestEmail.GetNewToken(Interactive: Boolean = False): Boolean;
var
    TimeoutTrg: Longword;
begin
    Result := False;
    FWaitSecs := 0;
    FCancelFlag := False;
    try       { V8.66 }
        if (FAccToken = '') or (FAccExpireDT < Now) then begin
            if (FRefrToken <> '') then
                Result := UpdateToken;
            if NOT Result then begin
                if NOT Interactive then Exit;
                FRestOAuth.AuthType := FOAAuthType;                           { V8.66 }
                FRestOAuth.OnOAuthAuthUrl := FOnOAAuthUrl;                    { V8.66 }
                Result := StartAuthorization;
                if NOT Result then Exit;

              // need to wait for the user to fill in the login using a brower windows
                if FLoginTimeout < 5 then FLoginTimeout := 60;
                TimeoutTrg := IcsGetTrgSecs (FLoginTimeout);
                while (FAccToken = '') do begin
                    HttpRest.CtrlSocket.ProcessMessages ;
                    if HttpRest.CtrlSocket.Terminated then break ;
                    if IcsTestTrgTick(TimeoutTrg) then break;
                    if FCancelFlag then break;
                    FWaitSecs := (IcsDiffTicks(IcsGetTickCountX, TimeoutTrg)) div TicksPerSecond ;
                end;
                Result := (FAccToken <> '');
            end;
        end
        else
            Result := True; // nothing to do, got an unexpired token
    finally
        FWaitSecs := 0;
        if FRestOAuth.SrvIsRunning then FRestOAuth.StopSrv;
        FRestOAuth.Close;
        if HttpRest.State = httpConnected then HttpRest.Close;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsRestEmail.CancelWait;
begin
    FCancelFlag := True;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ common get error handler }
procedure TIcsRestEmail.SetRestError;
var
    ErrJson: ISuperObject;
begin
    FLastError := HttpRest.ResponseRaw;
    if FLastError = '' then
        FLastError := HttpRest.LastResponse
    else begin
        if Assigned(HttpRest.ResponseJson) then begin
            ErrJson := HttpRest.ResponseJson.O['errors'];
            if Assigned(ErrJson) and (ErrJson.AsArray.Length > 0) then
                FLastError := ErrJson.AsArray.O[0].S['message']
            else begin
                ErrJson := HttpRest.ResponseJson.O['error'];
                if Assigned(ErrJson) then
                    FLastError := ErrJson.S['message'];
            end;
        end;
    end;
end;

{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ get information about who is logged-on, which we may not know due to
  OAuth2 authentification, primarily the email address, but it may not
  have an email account associated }
function TIcsRestEmail.GetProfile: boolean;
var
    EmailURL: String;
    StatCode: Integer;
begin
    Result := False;
    if NOT CommonSettings then Exit;
    if FRestEmailType = RestEmailGoogle then
        EmailURL := FBaseURL + 'me/profile'
    else if (FRestEmailType = RestEmailMSRest) or
                             (FRestEmailType = RestEmailMSSmtp) then
        EmailURL := FBaseURL + 'me/'
    else
        Exit;
    StatCode := HttpRest.RestRequest(httpGET, EmailURL, False, '');
    if (StatCode <> 200) then
        SetRestError
    else begin
        if Assigned(HttpRest.ResponseJson) then begin
            Result := True;
            FNewAccEmail := HttpRest.ResponseJson.S['emailAddress'];  // Google
            if FNewAccEmail = '' then begin
                FNewAccEmail := HttpRest.ResponseJson.S['mail'];      // Microsoft
                if FNewAccEmail = 'null' then FNewAccEmail := '';
            end;
            if FNewAccEmail = '' then
                FNewAccEmail := HttpRest.ResponseJson.S['userPrincipalName'];  // Microsoft
            FNewAccName := HttpRest.ResponseJson.S['displayName'];          // Microsoft
        end;
    end;
    FResponseRaw := HttpRest.ResponseRaw;
    FResponseJson := HttpRest.ResponseJson;
end;

{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ Google get list of email IDs, no headers or anything, currently just the first MaxNr }
{ Microsoft Outlook, also returns headera }
function TIcsRestEmail.ListEmails(const Query: String = '';
                    const MBLabels: String = 'INBOX'; MaxNr: Integer = 100): boolean;
var
    EmailURL: String;
    StatCode: Integer;
begin
    Result := False;
    if NOT CommonSettings then Exit;
    if FRestEmailType = RestEmailGoogle then begin
        HttpRest.RestParams.AddItem('maxResults', MaxNr);
        HttpRest.RestParams.AddItem('includeSpamTrash', True);
        if Query <> '' then
            HttpRest.RestParams.AddItem('q', Query);
        if MBLabels <> '' then
            HttpRest.RestParams.AddItem('labelIds', MBLabels, RPTypeArray);
         HttpRest.RestParams.AddItem('includeSpamTrash', False);
         EmailURL := FBaseURL + 'me/messages'
    end
    else if FRestEmailType = RestEmailMSRest then begin
        HttpRest.RestParams.AddItem('$top', MaxNr);
        HttpRest.RestParams.AddItem('$count', True);
        HttpRest.RestParams.AddItem('$format', 'json');
        HttpRest.RestParams.AddItem('$select', FHdrFieldList);
        if Query <> '' then
            HttpRest.RestParams.AddItem('$filter', Query);
        if MBLabels = '' then
            EmailURL := FBaseURL + 'me/messages'
         else
            EmailURL := FBaseURL + 'me/mailFolders/' + MBLabels + '/messages'
    end
    else
        Exit;
    StatCode := HttpRest.RestRequest(httpGET, EmailURL, False, '');
    if (StatCode <> 200) then
        SetRestError
    else begin
        if Assigned(HttpRest.ResponseJson) then begin
             Result := True;
         end;
    end;
    FResponseRaw := HttpRest.ResponseRaw;
    FResponseJson := HttpRest.ResponseJson;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsRestEmail.GetEmail(const Id: String; EmailFmt: TRestEmailFmt = EmailFmtHdr): boolean;
var
    EmailURL, FmtLit: String;
    StatCode: Integer;
begin
    Result := False;
    if NOT CommonSettings then Exit;
    if FRestEmailType = RestEmailGoogle then begin
        if EmailFmt = EmailFmtRaw then
            FmtLit := 'raw'
        else if EmailFmt = EmailFmtFull then
            FmtLit := 'full'
        else
            FmtLit := 'metadata';
        HttpRest.RestParams.AddItem('format', FmtLit);
        if (EmailFmt = EmailFmtHdr) and (FHdrFieldList <> '') then
            HttpRest.RestParams.AddItem('metadataHeaders', FHdrFieldList, RPTypeArray);
        EmailURL := FBaseURL + 'me/messages/' + Id;
    end
    else if FRestEmailType = RestEmailMSRest then begin
        HttpRest.RestParams.AddItem('$select', FHdrFieldList);
        EmailURL := FBaseURL + 'me/messages/' + Id;
    end
    else
        Exit;
    StatCode := HttpRest.RestRequest(httpGET, EmailURL, False, '');
    if (StatCode <> 200) then
        SetRestError
    else begin
        if Assigned(HttpRest.ResponseJson) then
            Result := True;
    end;
    FResponseRaw := HttpRest.ResponseRaw;
    FResponseJson := HttpRest.ResponseJson;
end;

{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsRestEmail.SendEmail(const Content: String): boolean;
var
    EmailURL: String;
    StatCode: Integer;
begin
    Result := False;
    if NOT CommonSettings then Exit;

  // Gmail needs an RFC822 raw email prepared by the SMTP client component
    if FRestEmailType = RestEmailGoogle then begin
        HttpRest.RestParams.AddItem('raw', IcsBase64UrlEncode(Content));
        HttpRest.RestParams.PContent := PContBodyJson;
        EmailURL := FBaseURL + 'me/messages/send';
    end

  // Microsoft Outlook sends message as Json
    else if FRestEmailType = RestEmailMSRest then begin
        EmailURL := FBaseURL + 'me/sendMail';
        HttpRest.RestParams.AddItem('message', Content, True); // raw json
        HttpRest.RestParams.PContent := PContBodyJson;
    end
    else
        Exit;
    StatCode := HttpRest.RestRequest(httpPOST, EmailURL, False, '');
    if (StatCode = 202) then     // Microsoft Outlook does not return any Id
        Result := True
    else if (StatCode <> 200) then
        SetRestError
    else begin
        if Assigned(HttpRest.ResponseJson) then begin
            Result := True;
            FLastEmailId := HttpRest.ResponseJson.S['id'];
         end;
    end;
    FResponseRaw := HttpRest.ResponseRaw;
    FResponseJson := HttpRest.ResponseJson;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TIcsRestEmail.DeleteEmail(const Id: String): boolean;
var
    EmailURL: String;
    StatCode: Integer;
begin
    Result := False;
    FLastEmailId := '';
    if NOT CommonSettings then Exit;
    if FRestEmailType = RestEmailGoogle then begin
        EmailURL := FBaseURL + 'me/messages/' + Id;
    end
    else if FRestEmailType = RestEmailMSRest then begin
        EmailURL := FBaseURL + 'me/messages/' + Id;
    end
    else
        Exit;
    StatCode := HttpRest.RestRequest(httpDELETE, EmailURL, False, '');
    if (StatCode <> 204) then
        SetRestError
    else begin
         Result := True;  // no response for delete
    end;
    FResponseRaw := HttpRest.ResponseRaw;
    FResponseJson := HttpRest.ResponseJson;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
{ TIcsInetAlive }
{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
constructor TIcsInetAlive.Create (Aowner: TComponent);
begin
    inherited Create(AOwner);
    HttpRest := TSslHttpRest.Create(self);
    HttpRest.OnHttpRestProg := AliveRestProg;
    HttpRest.OnRestRequestDone := AliveRestRequestDone;
    FDebugLevel := DebugNone;
    FTaskTimer := TIcsTimer.Create(HttpRest);
    FTaskTimer.OnTimer := TaskOnTimer;
    FTaskTimer.Interval := TicksPerSecond*5;
    Stop;   // reset stuff
    FAliveMethod := AliveMethHttp;
    FAliveNets :=  AliveNetv4;
// used for Windows 7 to Windows 10 RTM, hosted by CDN
//    FHostIPv4 :=  'www.msftncsi.com';
//    FHostIPv6 := 'ipv6.msftncsi.com';
//    FHttpPage := '/ncsi.txt';
//    FHttpText := 'Microsoft NCSI';
// used for Windows 10 1607 and later, hosted by Microsoft
    FHostIPv4 := 'www.msftconnecttest.com';
    FHostIPv6 := 'ipv6.msftconnecttest.com';
    FHttpPage := '/connecttest.txt';
    FHttpText := 'Microsoft Connect Test';
    FLocalIPv4 := ICS_ANY_HOST_V4;
    FLocalIPv6 := ICS_ANY_HOST_V6 ;
    FAutoStart := False;
    FOnlineSecs := 60;
    FOfflineSecs := 5;
    FFailedWaitSecs := FOfflineSecs*6; // adds OnlineSecs so offline 90 secs after last OK and six failures
    FPingHops := 25;     { V8.67 was 15, not enough }
    FPingMaxSecs := 4;
    FPingCheckAddr := True;
    FTaskTimer.Enabled := True;
end;

{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
destructor TIcsInetAlive.Destroy;
begin
    FTaskTimer.Enabled := False;
    FreeAndNil(FTaskTimer);
    FreeAndNil(HttpRest);
    inherited Destroy;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsInetAlive.Start;
begin
    FRunning := True;
    if FOnlineSecs < 10 then FOnlineSecs := 10;
    if FOfflineSecs < 5 then FOfflineSecs := 5;
    if FFailedWaitSecs < 5 then FFailedWaitSecs := 15;
    if FHttpPage = '' then FHttpPage := '/';
    if FHttpPage [1] <> '/' then FHttpPage := '/' + FHttpPage;
    FAliveIPv4 := AliveStatNone;
    FAliveIPv6 := AliveStatNone;
    FLastTickIPv4 := 0;
    FLastTickIPv6 := 0;
    FLastDTIPv4 := 0;
    FLastDTIPv6 := 0;
    FHttpBusy := False;
    FPingBusy := False;
    CheckNow;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsInetAlive.CheckNow;
begin
    if NOT FRunning then Exit;
    if (FAliveNets in [AliveNetv4, AliveNetBoth]) then
        StartCheck(4);    // set IPv4 trigger
    if IsIPv6Available and (FAliveNets in [AliveNetv6, AliveNetBoth]) then
        FTrgIPv6 := IcsGetTrgSecs64(2);
    if NOT FTaskTimer.Enabled then
        FTaskTimer.Enabled := True;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsInetAlive.Stop;
begin
    FRunning := False;
    FTaskTimer.Enabled := False;
    FTrgIPv4 := Trigger64Disabled;
    FTrgIPv6 := Trigger64Disabled;
    FAliveIPv4 := AliveStatNone;
    FAliveIPv6 := AliveStatNone;
    if HttpRest.Connected then HttpRest.Abort;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsInetAlive.AliveRestProg(Sender: TObject; LogOption: TLogOption; const Msg: string);
begin
    if NOT FRunning then Exit;
    if Assigned(FOnAliveProg) then
        FOnAliveProg(Self, LogOption, Msg) ;
end;


// combines IPv4 and IPv6 online results, not online until both tested and online
function TIcsInetAlive.TestBothOnline: TAliveStatus;
begin
    if FAliveNets = AliveNetv4 then
        Result := FAliveIPv4
    else if FAliveNets = AliveNetv6 then
        Result := FAliveIPv6
    else begin
        if (FAliveIPv4 = FAliveIPv6) then
            Result := FAliveIPv4
        else if (FAliveIPv4 = AliveStatNone) or (FAliveIPv6 = AliveStatNone) then
            Result := AliveStatNone    // wait for both results
         else
            Result := AliveStatOffline;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsInetAlive.SetOnline(Online: Boolean; IpType: Integer);
var
    OldOnline: TAliveStatus;
    S: String;
begin
    if IpType = 4 then begin
        OldOnline := FAliveIPv4;
        if Online then begin
            FAliveIPv4 := AliveStatOnline;
            FLastTickIPv4 := IcsGetTickCount64;
            FLastDTIPv4 := Now;
        end
        else begin
            FTrgIPv4 := IcsGetTrgSecs64(FOfflineSecs);  // faster check offline
            if FAliveIPv4 = AliveStatOnline then begin  // about to go offline
                if (IcsElapsedSecs64(FLastTickIPv4) > (FFailedWaitSecs + FOnlineSecs)) then
                    FAliveIPv4 := AliveStatOffline;
            end;
            if FAliveIPv4 = AliveStatNone then     // first test
                FAliveIPv4 := AliveStatOffline;
        end;
        if (OldOnline <> FAliveIPv4) then begin
            if FAliveIPv4 = AliveStatOnline then
                S := 'Online'
            else
                S := 'Offline';
            AliveRestProg(Self, loProtSpecInfo, 'IPv4 Connectivity ' + S);
            if Assigned(FOnAliveChange) then FOnAliveChange(Self);
        end;
    end
    else if IpType = 6 then begin
        OldOnline := FAliveIPv6;
        if Online then begin
            FAliveIPv6 := AliveStatOnline;
            FLastTickIPv6 := IcsGetTickCount64;
            FLastDTIPv6 := Now;
        end
        else begin
            FTrgIPv6 := IcsGetTrgSecs64(FOfflineSecs);  // faster check offline
            if FAliveIPv6 = AliveStatOnline then begin  // about to go offline
                if (IcsElapsedSecs64(FLastTickIPv4) > (FFailedWaitSecs + FOnlineSecs)) then
                    FAliveIPv6 := AliveStatOffline;
            end;
            if FAliveIPv6 = AliveStatNone then     // first test
                FAliveIPv6 := AliveStatOffline;
        end;
        if (OldOnline <> FAliveIPv6) then begin
            if FAliveIPv6 = AliveStatOnline then
                S := 'Online'
            else
                S := 'Offline';
            AliveRestProg(Self, loProtSpecInfo, 'IPv6 Connectivity ' + S);
            if Assigned(FOnAliveChange) then FOnAliveChange(Self);
        end;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsInetAlive.AliveRestRequestDone(Sender: TObject; RqType: THttpRequest; ErrCode: Word);
begin
    FHttpBusy := False;
    if NOT FRunning then Exit;
    FHttpRTT := IcsElapsedMsecs64(FStartTick);
    if (ErrCode <> 0) or (HttpRest.StatusCode <> 200) then begin
        ErrCode := 98;
        AliveRestProg(Self, loProtSpecErr, 'Check Alive Request to ' +
            HttpRest.URL + ' failed, error #' + IntToStr(ErrCode) +
              '. Status = ' + IntToStr(HttpRest.StatusCode) +
                 ' - ' + HttpRest.ReasonPhrase);
    end
    else if (FHttpText <> '') then begin
        if (Pos(FHttpText, Trim(HttpRest.FResponseRaw)) = 0) then begin
            ErrCode := 99;
            AliveRestProg(Self, loProtSpecErr, 'Check Alive Request to ' +
                HttpRest.URL + ' failed, mimatched response: ' +
                                        Copy(HttpRest.FResponseRaw, 1, 24));
        end;
    end;
    if (ErrCode = 0) then
        AliveRestProg(Self, loProtSpecInfo, 'Check Alive to ' + HttpRest.URL +
             ' (' + IcsFmtIpv6Addr(HttpRest.AddrResolvedStr) + ') took ' + IntToStr(FHttpRTT) + ' msecs') ;
    SetOnline((ErrCode=0), HttpRest.Tag);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsInetAlive.StartHttp(IpType: Integer);
var
    URL: string;
    StatCode: Integer;
begin
    FPingBusy := False;
    if IpType = 4 then begin
        URL := 'http://' + FHostIPv4 + FHttpPage;
        HttpRest.SocketFamily := sfIPv4;
        HttpRest.LocalAddr := FLocalIPv4;
    end
    else begin
        URL := 'http://' + FHostIPv6 + FHttpPage;
        HttpRest.SocketFamily := sfIPv6;
        HttpRest.LocalAddr6 := FLocalIPv6;
    end;
    HttpRest.Tag := IpType;
    HttpRest.DebugLevel := FDebugLevel;
    HttpRest.ProxyURL := FHttpProxy;
    HttpRest.Connection := 'Close';   // no keep-alive
    FStartTick := IcsGetTickCount64;
    FHttpRTT := 0;
    StatCode := HttpRest.RestRequest(httpGET, URL, True, '');   // async request
    if (StatCode = 0) then
        FHttpBusy := True
    else
        AliveRestProg(Self, loProtSpecErr, 'Check Alive Request to ' +
            HttpRest.URL + ' failed to Start, Code ' + IntToStr(StatCode));
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsInetAlive.PingTerminated(Sender: TObject);
var
    S: String;
begin
    FPingBusy := False;
    if NOT FRunning then Exit;
    try
        with Sender as TPingThread do
        begin
        // see if ping reached correct host, needs a high TTL
            if (ErrCode = 0) and FPingCheckAddr then
            begin
                if DnsHostIP <> ReplyIPAddr then
                begin
                    S:= 'Ping Did Not Reach Host ';
                    AliveRestProg(Self, loProtSpecErr, S + PingHostName + ', Request IP ' +
                               DnsHostIP + ', Reply IP ' + ReplyIPAddr + ' (' + ReplyHostName + ')') ;
                    ErrCode := 99 ;
                    ErrString := 'Ping Did Not Reach Host' ;
                end ;
            end ;
            if ErrCode <> 0 then begin
                AliveRestProg(Self, loProtSpecErr, 'Ping Failed to Host ' + PingHostName + ', Request IP ' +
                               DnsHostIP + ': ' + ErrString);
                SetOnline(False, PingId)
            end
            else begin
                AliveRestProg(Self, loProtSpecInfo, 'Check Alive Ping to ' + PingHostName +
                        ' (' + IcsFmtIpv6Addr(DnsHostIP) + ') took ' + IntToStr(ReplyRTT) + ' msecs') ;
                if FAliveMethod = AliveMethPing then
                    SetOnline(True, PingId)
                else
                    StartHttp(PingId);
            end;
        end;
    except
        on E:Exception do begin
            AliveRestProg(Self, loProtSpecErr, 'Ping Terminated Exception: ' + E.Message);
        end;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsInetAlive.StartCheck(IpType: Integer);

    procedure StartPing(IpType: Integer);
    begin
        with TPingThread.Create (True) do   // create suspended
        begin
            FreeOnTerminate := True;
            PingId := IpType;
            OnTerminate := PingTerminated;
            if IpType = 4 then begin
                PingHostName := FHostIPv4;
                PingSocketFamily := sfIPv4;
                PingSrcAddress := FLocalIPv4;
            end
            else begin
                PingHostName := FHostIPv6;
                PingSocketFamily := sfIPv6;
                PingSrcAddress6 := FLocalIPv6;
            end;
            PingTimeout := FPingMaxSecs * Integer (TicksPerSecond) ;
            PingTTL := FPingHops;
            PingLookupReply := FPingCheckAddr;
        {$IFDEF COMPILER14_UP}
            Start;
        {$ELSE}
            Resume;
        {$ENDIF}
            FPingBusy := True;
        end ;
    end;

begin
    try
        if FHttpBusy then Exit;
        if FPingBusy then Exit;
        if (IpType = 4) then begin
            if FAliveIPv4 = AliveStatOnline then
                FTrgIPv4 := IcsGetTrgSecs64(FOnlineSecs)
            else
                FTrgIPv4 := IcsGetTrgSecs64(FOfflineSecs);
            if FAliveMethod in [AliveMethPing, AliveMethBoth] then
                StartPing(4)
            else if FAliveMethod in [AliveMethHttp] then
                StartHttp(4);
        end
        else if (IpType = 6) then begin
            if FAliveIPv6 = AliveStatOnline then
                FTrgIPv6 := IcsGetTrgSecs64(FOnlineSecs)
            else
                FTrgIPv6 := IcsGetTrgSecs64(FOfflineSecs);
            if FAliveMethod in [AliveMethPing, AliveMethBoth] then
                StartPing(6)
            else if FAliveMethod in [AliveMethHttp] then
                StartHttp(6);
        end
        else
            AliveRestProg(Self, loProtSpecErr, 'Unknown IP Type');
    except
        on E:Exception do begin
            AliveRestProg(Self, loProtSpecErr, 'Check Alive Timer Exception: ' + E.Message);
            FHttpBusy := False;
            FPingBusy := False;
        end;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TIcsInetAlive.TaskOnTimer(Sender: TObject);

begin
    if(NOT FRunning) then begin
        if FAutoStart then begin
            FAutoStart := False;
            Start;
         end
         else
            FTaskTimer.Enabled := False;
         Exit;
    end;
    if IcsTestTrgTick64(FTrgIPv4) then begin
        StartCheck(4);
     end;
    if IcsTestTrgTick64(FTrgIPv6) then begin
        StartCheck(6);
     end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}

{$ENDIF USE_SSL}

end.
